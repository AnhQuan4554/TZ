/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * The Guardian is a modular open-source solution that includes best-in-class identity management and decentralized ledger technology (DLT) libraries. At the heart of the Guardian solution is a sophisticated Policy Workflow Engine (PWE) that enables applications to offer a requirements-based tokenization implementation.
 *
 * The version of the OpenAPI document: 2.10.0
 * Contact: info@envisionblockchain.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  did?: string;
}
/**
 *
 * @export
 * @interface Artifact
 */
export interface Artifact {
  /**
   *
   * @type {string}
   * @memberof Artifact
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Artifact
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Artifact
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof Artifact
   */
  extention?: string;
  /**
   *
   * @type {string}
   * @memberof Artifact
   */
  type?: string;
}
/**
 *
 * @export
 * @interface CommonSettings
 */
export interface CommonSettings {
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  operatorId?: string;
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  operatorKey?: string;
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   * @deprecated
   */
  nftApiKey?: string;
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  ipfsStorageApiKey?: string;
}
/**
 *
 * @export
 * @interface Contract
 */
export interface Contract {
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  contractId?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  isOwnerCreator?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  status?: string;
}
/**
 *
 * @export
 * @interface Credentials
 */
export interface Credentials {
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  password: string;
}
/**
 *
 * @export
 * @interface ExportModule
 */
export interface ExportModule {
  /**
   *
   * @type {string}
   * @memberof ExportModule
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof ExportModule
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ExportModule
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ExportModule
   */
  messageId?: string;
  /**
   *
   * @type {string}
   * @memberof ExportModule
   */
  owner?: string;
}
/**
 *
 * @export
 * @interface ExportPolicy
 */
export interface ExportPolicy {
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  tokens?: string;
}
/**
 *
 * @export
 * @interface ExportSchema
 */
export interface ExportSchema {
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface ExternalData
 */
export interface ExternalData {
  /**
   *
   * @type {string}
   * @memberof ExternalData
   */
  owner: string;
  /**
   *
   * @type {string}
   * @memberof ExternalData
   */
  policyTag: string;
  /**
   *
   * @type {object}
   * @memberof ExternalData
   */
  document: object;
}
/**
 *
 * @export
 * @interface HederaAccount
 */
export interface HederaAccount {
  /**
   *
   * @type {string}
   * @memberof HederaAccount
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof HederaAccount
   */
  key: string;
}
/**
 *
 * @export
 * @interface ImportSchema
 */
export interface ImportSchema {
  /**
   *
   * @type {Array<ImportSchemaSchemes>}
   * @memberof ImportSchema
   */
  schemes: Array<ImportSchemaSchemes>;
}
/**
 *
 * @export
 * @interface ImportSchemaSchemes
 */
export interface ImportSchemaSchemes {
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  document: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  entity: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  hash?: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  uuid: string;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  version?: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  version?: string;
}
/**
 *
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
  /**
   *
   * @type {string}
   * @memberof InlineObject10
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
  /**
   *
   * @type {string}
   * @memberof InlineObject11
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
  /**
   *
   * @type {string}
   * @memberof InlineObject12
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
  /**
   *
   * @type {string}
   * @memberof InlineObject14
   */
  did?: string;
}
/**
 *
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
  /**
   *
   * @type {string}
   * @memberof InlineObject15
   */
  mainPolicyTopicId: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject15
   */
  synchronizationTopicId: string;
}
/**
 *
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
  /**
   *
   * @type {string}
   * @memberof InlineObject17
   */
  description?: string;
}
/**
 *
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
  /**
   *
   * @type {string}
   * @memberof InlineObject18
   */
  contractId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject18
   */
  description?: string;
}
/**
 *
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
  /**
   *
   * @type {string}
   * @memberof InlineObject19
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {string}
   * @memberof InlineObject2
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
  /**
   *
   * @type {string}
   * @memberof InlineObject20
   */
  baseTokenId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject20
   */
  oppositeTokenId?: string;
  /**
   *
   * @type {number}
   * @memberof InlineObject20
   */
  baseTokenCount?: number;
  /**
   *
   * @type {number}
   * @memberof InlineObject20
   */
  oppositeTokenCount?: number;
}
/**
 *
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
  /**
   *
   * @type {string}
   * @memberof InlineObject21
   */
  baseTokenId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject21
   */
  oppositeTokenId?: string;
  /**
   *
   * @type {number}
   * @memberof InlineObject21
   */
  baseTokenCount?: number;
  /**
   *
   * @type {number}
   * @memberof InlineObject21
   */
  oppositeTokenCount?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof InlineObject21
   */
  baseTokenSerials?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof InlineObject21
   */
  oppositeTokenSerials?: Array<number>;
}
/**
 *
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
  /**
   *
   * @type {string}
   * @memberof InlineObject22
   */
  requestId?: string;
}
/**
 *
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
  /**
   *
   * @type {string}
   * @memberof InlineObject23
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   *
   * @type {string}
   * @memberof InlineObject3
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   *
   * @type {string}
   * @memberof InlineObject4
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   *
   * @type {string}
   * @memberof InlineObject5
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
  /**
   *
   * @type {string}
   * @memberof InlineObject6
   */
  version?: string;
}
/**
 *
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  policyVersion?: string;
}
/**
 *
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
  /**
   *
   * @type {string}
   * @memberof InlineObject8
   */
  policyVersion?: string;
}
/**
 *
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
  /**
   *
   * @type {string}
   * @memberof InlineObject9
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse200
   */
  balance?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  unit?: string;
  /**
   *
   * @type {InlineResponse200User}
   * @memberof InlineResponse200
   */
  user?: InlineResponse200User;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  groupLabel?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  groupName?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2001
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002
   */
  id?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  createDate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  hederaAccountId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  createDate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  owner?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  createDate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  documentURL?: string;
  /**
   *
   * @type {object}
   * @memberof InlineResponse2005
   */
  document?: object;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2006
   */
  totalCount?: number;
  /**
   *
   * @type {Log}
   * @memberof InlineResponse2006
   */
  logs?: Log;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2007
   */
  baseTokenRate?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2007
   */
  oppositeTokenRate?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  contractId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  description?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200User
 */
export interface InlineResponse200User {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200User
   */
  did?: string;
}
/**
 *
 * @export
 * @interface Log
 */
export interface Log {
  /**
   *
   * @type {string}
   * @memberof Log
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Log
   */
  datetime?: string;
  /**
   *
   * @type {string}
   * @memberof Log
   */
  message?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Log
   */
  attributes?: Array<string>;
}
/**
 *
 * @export
 * @interface LogFilters
 */
export interface LogFilters {
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LogFilters
   */
  attributes?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof LogFilters
   */
  pageSize?: number;
  /**
   *
   * @type {number}
   * @memberof LogFilters
   */
  pageIndex?: number;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  sortDirection?: LogFiltersSortDirectionEnum;
}

export const LogFiltersSortDirectionEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type LogFiltersSortDirectionEnum =
  typeof LogFiltersSortDirectionEnum[keyof typeof LogFiltersSortDirectionEnum];

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 *
 * @export
 * @interface Module
 */
export interface Module {
  /**
   *
   * @type {string}
   * @memberof Module
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Module
   */
  config?: object;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  creator?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  topicId?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  messageId?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  codeVersion?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  createDate?: string;
  /**
   *
   * @type {string}
   * @memberof Module
   */
  type?: string;
}
/**
 *
 * @export
 * @interface MultiPolicyConfig
 */
export interface MultiPolicyConfig {
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  instanceTopicId?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  mainPolicyTopicId?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  synchronizationTopicId?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  policyOwner?: string;
  /**
   *
   * @type {string}
   * @memberof MultiPolicyConfig
   */
  user?: string;
}
/**
 *
 * @export
 * @interface PolicyBlock
 */
export interface PolicyBlock {
  /**
   *
   * @type {string}
   * @memberof PolicyBlock
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PolicyBlock
   */
  blockType: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyBlock
   */
  isActive: boolean;
  /**
   *
   * @type {object}
   * @memberof PolicyBlock
   */
  uiMetaData: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PolicyBlock
   */
  blocks?: Array<object>;
}
/**
 *
 * @export
 * @interface PolicyBlockData
 */
export interface PolicyBlockData {
  /**
   *
   * @type {string}
   * @memberof PolicyBlockData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PolicyBlockData
   */
  blockType?: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyBlockData
   */
  isActive: boolean;
  /**
   *
   * @type {object}
   * @memberof PolicyBlockData
   */
  uiMetaData: object;
  /**
   *
   * @type {object}
   * @memberof PolicyBlockData
   */
  data: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PolicyBlockData
   */
  fields?: Array<object>;
  /**
   *
   * @type {number}
   * @memberof PolicyBlockData
   */
  index?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyBlockData
   */
  roles?: Array<string>;
  /**
   *
   * @type {Array<PolicyBlock>}
   * @memberof PolicyBlockData
   */
  blocks?: Array<PolicyBlock>;
}
/**
 *
 * @export
 * @interface PolicyConfig
 */
export interface PolicyConfig {
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  topicDescription: string;
  /**
   *
   * @type {object}
   * @memberof PolicyConfig
   */
  config: object;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  owner?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyConfig
   */
  policyRoles?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  topicId: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  policyTag: string;
  /**
   *
   * @type {Array<PolicyConfigPolicyTopics>}
   * @memberof PolicyConfig
   */
  policyTopics?: Array<PolicyConfigPolicyTopics>;
}
/**
 *
 * @export
 * @interface PolicyConfigPolicyTopics
 */
export interface PolicyConfigPolicyTopics {
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  type?: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyConfigPolicyTopics
   */
  static?: boolean;
}
/**
 *
 * @export
 * @interface PreviewModule
 */
export interface PreviewModule {
  /**
   *
   * @type {Module}
   * @memberof PreviewModule
   */
  module?: Module;
}
/**
 *
 * @export
 * @interface PreviewPolicy
 */
export interface PreviewPolicy {
  /**
   *
   * @type {object}
   * @memberof PreviewPolicy
   */
  policy: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PreviewPolicy
   */
  schemas: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof PreviewPolicy
   */
  tokens: Array<object>;
}
/**
 *
 * @export
 * @interface PublishModule
 */
export interface PublishModule {
  /**
   *
   * @type {object}
   * @memberof PublishModule
   */
  errors?: object;
  /**
   *
   * @type {boolean}
   * @memberof PublishModule
   */
  isValid?: boolean;
  /**
   *
   * @type {Module}
   * @memberof PublishModule
   */
  module?: Module;
}
/**
 *
 * @export
 * @interface PublishPolicy
 */
export interface PublishPolicy {
  /**
   *
   * @type {Array<object>}
   * @memberof PublishPolicy
   */
  errors: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof PublishPolicy
   */
  isValid: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof PublishPolicy
   */
  policies: Array<object>;
}
/**
 *
 * @export
 * @interface RetireRequest
 */
export interface RetireRequest {
  /**
   *
   * @type {string}
   * @memberof RetireRequest
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof RetireRequest
   */
  contractId?: string;
  /**
   *
   * @type {string}
   * @memberof RetireRequest
   */
  baseTokenId?: string;
  /**
   *
   * @type {string}
   * @memberof RetireRequest
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof RetireRequest
   */
  oppositeTokenId?: string;
  /**
   *
   * @type {number}
   * @memberof RetireRequest
   */
  baseTokenCount?: number;
  /**
   *
   * @type {number}
   * @memberof RetireRequest
   */
  oppositeTokenCount?: number;
}
/**
 *
 * @export
 * @interface Schema
 */
export interface Schema {
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  iri?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  entity: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  hash?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  document: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  topicId?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface Session
 */
export interface Session {
  /**
   *
   * @type {string}
   * @memberof Session
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  accessToken: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {string}
   * @memberof Task
   */
  taskId?: string;
  /**
   *
   * @type {number}
   * @memberof Task
   */
  expectation?: number;
}
/**
 *
 * @export
 * @interface TaskStatus
 */
export interface TaskStatus {
  /**
   *
   * @type {string}
   * @memberof TaskStatus
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof TaskStatus
   */
  name?: string;
  /**
   *
   * @type {Array<TaskStatusStatuses>}
   * @memberof TaskStatus
   */
  statuses?: Array<TaskStatusStatuses>;
  /**
   *
   * @type {object}
   * @memberof TaskStatus
   */
  result?: object;
  /**
   *
   * @type {object}
   * @memberof TaskStatus
   */
  error?: object;
}
/**
 *
 * @export
 * @interface TaskStatusStatuses
 */
export interface TaskStatusStatuses {
  /**
   *
   * @type {string}
   * @memberof TaskStatusStatuses
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof TaskStatusStatuses
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  changeSupply: boolean;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  decimals: string;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableAdmin: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableFreeze: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableKYC: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableWipe: boolean;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  initialSupply: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenName: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenSymbol: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenType: string;
}
/**
 *
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenId: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenName: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenSymbol: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenType: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  decimals: string;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  associated: boolean;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  balance: string;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  frozen: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  kyc: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  enableAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  enableKYC?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  enableFreeze?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  enableWipe?: boolean;
}
/**
 *
 * @export
 * @interface TrustChains
 */
export interface TrustChains {
  /**
   *
   * @type {Array<TrustChainsChain>}
   * @memberof TrustChains
   */
  chain: Array<TrustChainsChain>;
  /**
   *
   * @type {Array<TrustChainsUserMap>}
   * @memberof TrustChains
   */
  userMap: Array<TrustChainsUserMap>;
}
/**
 *
 * @export
 * @interface TrustChainsChain
 */
export interface TrustChainsChain {
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  tag: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  schema: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  owner: string;
  /**
   *
   * @type {object}
   * @memberof TrustChainsChain
   */
  document: object;
}
/**
 *
 * @export
 * @interface TrustChainsUserMap
 */
export interface TrustChainsUserMap {
  /**
   *
   * @type {string}
   * @memberof TrustChainsUserMap
   */
  did: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsUserMap
   */
  username: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  confirmed?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  failed?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hederaAccountId?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hederaAccountKey?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  did?: string;
  /**
   *
   * @type {object}
   * @memberof User
   */
  didDocument?: object;
  /**
   *
   * @type {object}
   * @memberof User
   */
  vcDocument?: object;
  /**
   *
   * @type {string}
   * @memberof User
   */
  parent?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  topicId?: string;
}
/**
 *
 * @export
 * @interface ValidateModule
 */
export interface ValidateModule {
  /**
   *
   * @type {Module}
   * @memberof ValidateModule
   */
  module?: Module;
  /**
   *
   * @type {object}
   * @memberof ValidateModule
   */
  results?: object;
}
/**
 *
 * @export
 * @interface ValidatePolicy
 */
export interface ValidatePolicy {
  /**
   *
   * @type {object}
   * @memberof ValidatePolicy
   */
  config: object;
  /**
   *
   * @type {object}
   * @memberof ValidatePolicy
   */
  results: object;
}
/**
 *
 * @export
 * @interface VerifiablePresentation
 */
export interface VerifiablePresentation {
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  policyId: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  signature: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  tag: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  updateDate: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  createDate: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  owner: string;
  /**
   *
   * @type {object}
   * @memberof VerifiablePresentation
   */
  document: object;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Requests current Hedera account balance.
     * @summary Returns user\'s Hedera account balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsBalanceGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/balance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all users except those with roles Standard Registry and Auditor. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns a list of users, excluding Standard Registry and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsLoginPost: async (
      credentials: Credentials,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'credentials' is not null or undefined
      assertParamExists('accountsLoginPost', 'credentials', credentials);
      const localVarPath = `/accounts/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentials,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRegisterPost: async (
      credentials: Credentials,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'credentials' is not null or undefined
      assertParamExists('accountsRegisterPost', 'credentials', credentials);
      const localVarPath = `/accounts/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentials,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    accountsRootAuthoritiesGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/root-authorities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsSessionGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/session`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsStandardRegistriesGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/standard-registries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Requests current Hedera account balance.
     * @summary Returns user\'s Hedera account balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsBalanceGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsBalanceGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all users except those with roles Standard Registry and Auditor. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns a list of users, excluding Standard Registry and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsLoginPost(
      credentials: Credentials,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsLoginPost(credentials, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsRegisterPost(
      credentials: Credentials,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsRegisterPost(
          credentials,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async accountsRootAuthoritiesGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsRootAuthoritiesGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsSessionGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsSessionGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsStandardRegistriesGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsStandardRegistriesGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Requests current Hedera account balance.
     * @summary Returns user\'s Hedera account balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsBalanceGet(options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp
        .accountsBalanceGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all users except those with roles Standard Registry and Auditor. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns a list of users, excluding Standard Registry and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .accountsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsLoginPost(
      credentials: Credentials,
      options?: any,
    ): AxiosPromise<Session> {
      return localVarFp
        .accountsLoginPost(credentials, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRegisterPost(
      credentials: Credentials,
      options?: any,
    ): AxiosPromise<Account> {
      return localVarFp
        .accountsRegisterPost(credentials, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    accountsRootAuthoritiesGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .accountsRootAuthoritiesGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsSessionGet(options?: any): AxiosPromise<Session> {
      return localVarFp
        .accountsSessionGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all Standard Registries.
     * @summary Returns all Standard Registries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsStandardRegistriesGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .accountsStandardRegistriesGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Requests current Hedera account balance.
   * @summary Returns user\'s Hedera account balance.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsBalanceGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsBalanceGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all users except those with roles Standard Registry and Auditor. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns a list of users, excluding Standard Registry and Auditors.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs user into the system.
   * @param {Credentials} credentials Object that contains username and password fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsLoginPost(
    credentials: Credentials,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .accountsLoginPost(credentials, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers a new user account.
   * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsRegisterPost(
    credentials: Credentials,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .accountsRegisterPost(credentials, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all Standard Registries.
   * @summary Returns all Standard Registries.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsRootAuthoritiesGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsRootAuthoritiesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns current user session.
   * @summary Returns current session of the user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsSessionGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsSessionGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all Standard Registries.
   * @summary Returns all Standard Registries.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsStandardRegistriesGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsStandardRegistriesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Delete artifact.
     * @summary Delete artifact.
     * @param {string} artifactId Artifact identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactArtifactIdDelete: async (
      artifactId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'artifactId' is not null or undefined
      assertParamExists('artifactArtifactIdDelete', 'artifactId', artifactId);
      const localVarPath = `/artifact/{artifactId}`.replace(
        `{${'artifactId'}}`,
        encodeURIComponent(String(artifactId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all artifacts.
     * @summary Returns all artifacts.
     * @param {string} [policyId] Policy identifier
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactGet: async (
      policyId?: string,
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/artifact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (policyId !== undefined) {
        localVarQueryParameter['policyId'] = policyId;
      }

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload artifact. For users with the Standard Registry role only.
     * @summary Upload Artifact.
     * @param {string} policyId Policy identifier
     * @param {Array<any>} [artifacts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactPolicyIdPost: async (
      policyId: string,
      artifacts?: Array<any>,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('artifactPolicyIdPost', 'policyId', policyId);
      const localVarPath = `/artifact/{policyId}`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (artifacts) {
        artifacts.forEach((element) => {
          localVarFormParams.append('artifacts', element as any);
        });
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ArtifactsApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete artifact.
     * @summary Delete artifact.
     * @param {string} artifactId Artifact identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async artifactArtifactIdDelete(
      artifactId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.artifactArtifactIdDelete(
          artifactId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all artifacts.
     * @summary Returns all artifacts.
     * @param {string} [policyId] Policy identifier
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async artifactGet(
      policyId?: string,
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Artifact>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.artifactGet(
        policyId,
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Upload artifact. For users with the Standard Registry role only.
     * @summary Upload Artifact.
     * @param {string} policyId Policy identifier
     * @param {Array<any>} [artifacts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async artifactPolicyIdPost(
      policyId: string,
      artifacts?: Array<any>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Artifact>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.artifactPolicyIdPost(
          policyId,
          artifacts,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ArtifactsApiFp(configuration);
  return {
    /**
     * Delete artifact.
     * @summary Delete artifact.
     * @param {string} artifactId Artifact identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactArtifactIdDelete(
      artifactId: string,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .artifactArtifactIdDelete(artifactId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all artifacts.
     * @summary Returns all artifacts.
     * @param {string} [policyId] Policy identifier
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactGet(
      policyId?: string,
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Artifact>> {
      return localVarFp
        .artifactGet(policyId, pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Upload artifact. For users with the Standard Registry role only.
     * @summary Upload Artifact.
     * @param {string} policyId Policy identifier
     * @param {Array<any>} [artifacts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    artifactPolicyIdPost(
      policyId: string,
      artifacts?: Array<any>,
      options?: any,
    ): AxiosPromise<Array<Artifact>> {
      return localVarFp
        .artifactPolicyIdPost(policyId, artifacts, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
  /**
   * Delete artifact.
   * @summary Delete artifact.
   * @param {string} artifactId Artifact identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArtifactsApi
   */
  public artifactArtifactIdDelete(
    artifactId: string,
    options?: AxiosRequestConfig,
  ) {
    return ArtifactsApiFp(this.configuration)
      .artifactArtifactIdDelete(artifactId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all artifacts.
   * @summary Returns all artifacts.
   * @param {string} [policyId] Policy identifier
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArtifactsApi
   */
  public artifactGet(
    policyId?: string,
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ArtifactsApiFp(this.configuration)
      .artifactGet(policyId, pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Upload artifact. For users with the Standard Registry role only.
   * @summary Upload Artifact.
   * @param {string} policyId Policy identifier
   * @param {Array<any>} [artifacts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArtifactsApi
   */
  public artifactPolicyIdPost(
    policyId: string,
    artifacts?: Array<any>,
    options?: AxiosRequestConfig,
  ) {
    return ArtifactsApiFp(this.configuration)
      .artifactPolicyIdPost(policyId, artifacts, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates new contract pair. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new contract pair.
     * @param {string} contractId Contract identifier
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdPairPost: async (
      contractId: string,
      inlineObject20?: InlineObject20,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        'contractsContractIdPairPost',
        'contractId',
        contractId,
      );
      const localVarPath = `/contracts/{contractId}/pair`.replace(
        `{${'contractId'}}`,
        encodeURIComponent(String(contractId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject20,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new contract retire request.
     * @summary Creates new contract retire request.
     * @param {string} contractId Contract identifier
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdRetireRequestPost: async (
      contractId: string,
      inlineObject21?: InlineObject21,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        'contractsContractIdRetireRequestPost',
        'contractId',
        contractId,
      );
      const localVarPath = `/contracts/{contractId}/retire/request`.replace(
        `{${'contractId'}}`,
        encodeURIComponent(String(contractId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject21,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update contract status. Only users with the Standard Registry role are allowed to make the request.
     * @summary Update contract status.
     * @param {string} contractId Contract identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdStatusPost: async (
      contractId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        'contractsContractIdStatusPost',
        'contractId',
        contractId,
      );
      const localVarPath = `/contracts/{contractId}/status`.replace(
        `{${'contractId'}}`,
        encodeURIComponent(String(contractId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add new contract user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Add new contract user.
     * @param {string} contractId Contract identifier
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdUserPost: async (
      contractId: string,
      inlineObject19?: InlineObject19,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        'contractsContractIdUserPost',
        'contractId',
        contractId,
      );
      const localVarPath = `/contracts/{contractId}/user`.replace(
        `{${'contractId'}}`,
        encodeURIComponent(String(contractId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject19,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all contracts.
     * @summary Returns all contracts.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Import new contract.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsImportPost: async (
      inlineObject18?: InlineObject18,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts/import`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject18,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all contracts pairs.
     * @summary Returns all contracts pairs.
     * @param {string} [baseTokenId] Base token identifier
     * @param {string} [oppositeTokenId] Opposite token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsPairGet: async (
      baseTokenId?: string,
      oppositeTokenId?: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts/pair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (baseTokenId !== undefined) {
        localVarQueryParameter['baseTokenId'] = baseTokenId;
      }

      if (oppositeTokenId !== undefined) {
        localVarQueryParameter['oppositeTokenId'] = oppositeTokenId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new contract.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsPost: async (
      inlineObject17?: InlineObject17,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject17,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retire tokens. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retire tokens.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetirePost: async (
      inlineObject22?: InlineObject22,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts/retire`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject22,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel contract requests.
     * @summary Cancel contract requests.
     * @param {string} requestId Request Identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetireRequestDelete: async (
      requestId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('contractsRetireRequestDelete', 'requestId', requestId);
      const localVarPath = `/contracts/retire/request`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (requestId !== undefined) {
        localVarQueryParameter['requestId'] = requestId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all contract requests.
     * @summary Returns all contract requests.
     * @param {string} [contractId] Contract Identifier.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetireRequestGet: async (
      contractId?: string,
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts/retire/request`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (contractId !== undefined) {
        localVarQueryParameter['contractId'] = contractId;
      }

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ContractsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates new contract pair. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new contract pair.
     * @param {string} contractId Contract identifier
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsContractIdPairPost(
      contractId: string,
      inlineObject20?: InlineObject20,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsContractIdPairPost(
          contractId,
          inlineObject20,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new contract retire request.
     * @summary Creates new contract retire request.
     * @param {string} contractId Contract identifier
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsContractIdRetireRequestPost(
      contractId: string,
      inlineObject21?: InlineObject21,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetireRequest>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsContractIdRetireRequestPost(
          contractId,
          inlineObject21,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Update contract status. Only users with the Standard Registry role are allowed to make the request.
     * @summary Update contract status.
     * @param {string} contractId Contract identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsContractIdStatusPost(
      contractId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsContractIdStatusPost(
          contractId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Add new contract user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Add new contract user.
     * @param {string} contractId Contract identifier
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsContractIdUserPost(
      contractId: string,
      inlineObject19?: InlineObject19,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsContractIdUserPost(
          contractId,
          inlineObject19,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all contracts.
     * @summary Returns all contracts.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Contract>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contractsGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Import new contract.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsImportPost(
      inlineObject18?: InlineObject18,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsImportPost(
          inlineObject18,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all contracts pairs.
     * @summary Returns all contracts pairs.
     * @param {string} [baseTokenId] Base token identifier
     * @param {string} [oppositeTokenId] Opposite token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsPairGet(
      baseTokenId?: string,
      oppositeTokenId?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse2007>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsPairGet(
          baseTokenId,
          oppositeTokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new contract.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsPost(
      inlineObject17?: InlineObject17,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contractsPost(
        inlineObject17,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retire tokens. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retire tokens.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsRetirePost(
      inlineObject22?: InlineObject22,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsRetirePost(
          inlineObject22,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Cancel contract requests.
     * @summary Cancel contract requests.
     * @param {string} requestId Request Identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsRetireRequestDelete(
      requestId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsRetireRequestDelete(
          requestId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all contract requests.
     * @summary Returns all contract requests.
     * @param {string} [contractId] Contract Identifier.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contractsRetireRequestGet(
      contractId?: string,
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RetireRequest>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contractsRetireRequestGet(
          contractId,
          pageIndex,
          pageSize,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContractsApiFp(configuration);
  return {
    /**
     * Creates new contract pair. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new contract pair.
     * @param {string} contractId Contract identifier
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdPairPost(
      contractId: string,
      inlineObject20?: InlineObject20,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .contractsContractIdPairPost(contractId, inlineObject20, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new contract retire request.
     * @summary Creates new contract retire request.
     * @param {string} contractId Contract identifier
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdRetireRequestPost(
      contractId: string,
      inlineObject21?: InlineObject21,
      options?: any,
    ): AxiosPromise<RetireRequest> {
      return localVarFp
        .contractsContractIdRetireRequestPost(
          contractId,
          inlineObject21,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update contract status. Only users with the Standard Registry role are allowed to make the request.
     * @summary Update contract status.
     * @param {string} contractId Contract identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdStatusPost(
      contractId: string,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .contractsContractIdStatusPost(contractId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add new contract user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Add new contract user.
     * @param {string} contractId Contract identifier
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsContractIdUserPost(
      contractId: string,
      inlineObject19?: InlineObject19,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .contractsContractIdUserPost(contractId, inlineObject19, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all contracts.
     * @summary Returns all contracts.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Contract>> {
      return localVarFp
        .contractsGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Import new contract.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsImportPost(
      inlineObject18?: InlineObject18,
      options?: any,
    ): AxiosPromise<Contract> {
      return localVarFp
        .contractsImportPost(inlineObject18, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all contracts pairs.
     * @summary Returns all contracts pairs.
     * @param {string} [baseTokenId] Base token identifier
     * @param {string} [oppositeTokenId] Opposite token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsPairGet(
      baseTokenId?: string,
      oppositeTokenId?: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse2007>> {
      return localVarFp
        .contractsPairGet(baseTokenId, oppositeTokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new contract.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsPost(
      inlineObject17?: InlineObject17,
      options?: any,
    ): AxiosPromise<Contract> {
      return localVarFp
        .contractsPost(inlineObject17, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retire tokens. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retire tokens.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetirePost(
      inlineObject22?: InlineObject22,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .contractsRetirePost(inlineObject22, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancel contract requests.
     * @summary Cancel contract requests.
     * @param {string} requestId Request Identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetireRequestDelete(
      requestId: string,
      options?: any,
    ): AxiosPromise<boolean> {
      return localVarFp
        .contractsRetireRequestDelete(requestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all contract requests.
     * @summary Returns all contract requests.
     * @param {string} [contractId] Contract Identifier.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The numbers of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contractsRetireRequestGet(
      contractId?: string,
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<RetireRequest>> {
      return localVarFp
        .contractsRetireRequestGet(contractId, pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
  /**
   * Creates new contract pair. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates new contract pair.
   * @param {string} contractId Contract identifier
   * @param {InlineObject20} [inlineObject20]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsContractIdPairPost(
    contractId: string,
    inlineObject20?: InlineObject20,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsContractIdPairPost(contractId, inlineObject20, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new contract retire request.
   * @summary Creates new contract retire request.
   * @param {string} contractId Contract identifier
   * @param {InlineObject21} [inlineObject21]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsContractIdRetireRequestPost(
    contractId: string,
    inlineObject21?: InlineObject21,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsContractIdRetireRequestPost(contractId, inlineObject21, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update contract status. Only users with the Standard Registry role are allowed to make the request.
   * @summary Update contract status.
   * @param {string} contractId Contract identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsContractIdStatusPost(
    contractId: string,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsContractIdStatusPost(contractId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add new contract user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Add new contract user.
   * @param {string} contractId Contract identifier
   * @param {InlineObject19} [inlineObject19]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsContractIdUserPost(
    contractId: string,
    inlineObject19?: InlineObject19,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsContractIdUserPost(contractId, inlineObject19, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all contracts.
   * @summary Returns all contracts.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
   * @param {number} [pageSize] The numbers of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
   * @summary Import new contract.
   * @param {InlineObject18} [inlineObject18]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsImportPost(
    inlineObject18?: InlineObject18,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsImportPost(inlineObject18, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all contracts pairs.
   * @summary Returns all contracts pairs.
   * @param {string} [baseTokenId] Base token identifier
   * @param {string} [oppositeTokenId] Opposite token identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsPairGet(
    baseTokenId?: string,
    oppositeTokenId?: string,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsPairGet(baseTokenId, oppositeTokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new contract. Only users with the Standard Registry role are allowed to make the request.
   * @summary Create new contract.
   * @param {InlineObject17} [inlineObject17]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsPost(
    inlineObject17?: InlineObject17,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsPost(inlineObject17, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retire tokens. Only users with the Standard Registry role are allowed to make the request.
   * @summary Retire tokens.
   * @param {InlineObject22} [inlineObject22]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsRetirePost(
    inlineObject22?: InlineObject22,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsRetirePost(inlineObject22, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel contract requests.
   * @summary Cancel contract requests.
   * @param {string} requestId Request Identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsRetireRequestDelete(
    requestId: string,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsRetireRequestDelete(requestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all contract requests.
   * @summary Returns all contract requests.
   * @param {string} [contractId] Contract Identifier.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
   * @param {number} [pageSize] The numbers of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public contractsRetireRequestGet(
    contractId?: string,
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ContractsApiFp(this.configuration)
      .contractsRetireRequestGet(contractId, pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DemoApi - axios parameter creator
 * @export
 */
export const DemoApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @summary Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demoPushRandomKeyGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/demo/push/randomKey`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRandomKeyGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/demo/randomKey`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRegisteredUsersGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/demo/registeredUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DemoApi - functional programming interface
 * @export
 */
export const DemoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DemoApiAxiosParamCreator(configuration);
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @summary Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async demoPushRandomKeyGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.demoPushRandomKeyGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async demoRandomKeyGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HederaAccount>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.demoRandomKeyGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async demoRegisteredUsersGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Account & object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.demoRegisteredUsersGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DemoApi - factory interface
 * @export
 */
export const DemoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DemoApiFp(configuration);
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @summary Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demoPushRandomKeyGet(options?: any): AxiosPromise<Task> {
      return localVarFp
        .demoPushRandomKeyGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRandomKeyGet(options?: any): AxiosPromise<HederaAccount> {
      return localVarFp
        .demoRandomKeyGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRegisteredUsersGet(
      options?: any,
    ): AxiosPromise<Array<Account & object>> {
      return localVarFp
        .demoRegisteredUsersGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
export class DemoApi extends BaseAPI {
  /**
   * Generates a new Hedera account with a random private key.
   * @summary Generates a new Hedera account with a random private key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DemoApi
   */
  public demoPushRandomKeyGet(options?: AxiosRequestConfig) {
    return DemoApiFp(this.configuration)
      .demoPushRandomKeyGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generates a new Hedera account with a random private key.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DemoApi
   */
  public demoRandomKeyGet(options?: AxiosRequestConfig) {
    return DemoApiFp(this.configuration)
      .demoRandomKeyGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all registered user accounts.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DemoApi
   */
  public demoRegisteredUsersGet(options?: AxiosRequestConfig) {
    return DemoApiFp(this.configuration)
      .demoRegisteredUsersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalPost: async (
      externalData: ExternalData,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalData' is not null or undefined
      assertParamExists('externalPost', 'externalData', externalData);
      const localVarPath = `/external`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        externalData,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration);
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalPost(
      externalData: ExternalData,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.externalPost(
        externalData,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ExternalApiFp(configuration);
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalPost(
      externalData: ExternalData,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .externalPost(externalData, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
  /**
   * Sends data from an external source.
   * @summary Sends data from an external source.
   * @param {ExternalData} externalData Object that contains a VC Document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExternalApi
   */
  public externalPost(
    externalData: ExternalData,
    options?: AxiosRequestConfig,
  ) {
    return ExternalApiFp(this.configuration)
      .externalPost(externalData, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IpfsApi - axios parameter creator
 * @export
 */
export const IpfsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get file from ipfs.
     * @summary Get file from ipfs.
     * @param {string} cid File CID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFileCidGet: async (
      cid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'cid' is not null or undefined
      assertParamExists('ipfsFileCidGet', 'cid', cid);
      const localVarPath = `/ipfs/file/{cid}`.replace(
        `{${'cid'}}`,
        encodeURIComponent(String(cid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFilePost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ipfsFilePost', 'body', body);
      const localVarPath = `/ipfs/file/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IpfsApi - functional programming interface
 * @export
 */
export const IpfsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IpfsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get file from ipfs.
     * @summary Get file from ipfs.
     * @param {string} cid File CID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ipfsFileCidGet(
      cid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ipfsFileCidGet(
        cid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ipfsFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ipfsFilePost(
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * IpfsApi - factory interface
 * @export
 */
export const IpfsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IpfsApiFp(configuration);
  return {
    /**
     * Get file from ipfs.
     * @summary Get file from ipfs.
     * @param {string} cid File CID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFileCidGet(cid: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .ipfsFileCidGet(cid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFilePost(body: any, options?: any): AxiosPromise<string> {
      return localVarFp
        .ipfsFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IpfsApi - object-oriented interface
 * @export
 * @class IpfsApi
 * @extends {BaseAPI}
 */
export class IpfsApi extends BaseAPI {
  /**
   * Get file from ipfs.
   * @summary Get file from ipfs.
   * @param {string} cid File CID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IpfsApi
   */
  public ipfsFileCidGet(cid: string, options?: AxiosRequestConfig) {
    return IpfsApiFp(this.configuration)
      .ipfsFileCidGet(cid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add file to ipfs.
   * @summary Add file to ipfs.
   * @param {any} body Data array of file.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IpfsApi
   */
  public ipfsFilePost(body: any, options?: AxiosRequestConfig) {
    return IpfsApiFp(this.configuration)
      .ipfsFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns logs attributes. For users with the Standard Registry role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsAttributesGet: async (
      name?: string,
      existingAttributes?: Array<string>,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/logs/attributes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (existingAttributes) {
        localVarQueryParameter['existingAttributes'] = existingAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns logs. For users with the Standard Registry role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsPost: async (
      logFilters?: LogFilters,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/logs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logFilters,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns logs attributes. For users with the Standard Registry role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logsAttributesGet(
      name?: string,
      existingAttributes?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.logsAttributesGet(
          name,
          existingAttributes,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns logs. For users with the Standard Registry role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logsPost(
      logFilters?: LogFilters,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2006>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logsPost(
        logFilters,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LogsApiFp(configuration);
  return {
    /**
     * Returns logs attributes. For users with the Standard Registry role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsAttributesGet(
      name?: string,
      existingAttributes?: Array<string>,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .logsAttributesGet(name, existingAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns logs. For users with the Standard Registry role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsPost(
      logFilters?: LogFilters,
      options?: any,
    ): AxiosPromise<InlineResponse2006> {
      return localVarFp
        .logsPost(logFilters, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
  /**
   * Returns logs attributes. For users with the Standard Registry role only.
   * @summary Returns logs attributes.
   * @param {string} [name] Part of name.
   * @param {Array<string>} [existingAttributes] Attributes to exclude.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogsApi
   */
  public logsAttributesGet(
    name?: string,
    existingAttributes?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return LogsApiFp(this.configuration)
      .logsAttributesGet(name, existingAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns logs. For users with the Standard Registry role only.
   * @summary Returns logs.
   * @param {LogFilters} [logFilters] Log filters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogsApi
   */
  public logsPost(logFilters?: LogFilters, options?: AxiosRequestConfig) {
    return LogsApiFp(this.configuration)
      .logsPost(logFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ModulesApi - axios parameter creator
 * @export
 */
export const ModulesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all modules. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all modules.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/modules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new module and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportFilePost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('modulesImportFilePost', 'body', body);
      const localVarPath = `/modules/import/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the module from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportFilePreviewPost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('modulesImportFilePreviewPost', 'body', body);
      const localVarPath = `/modules/import/file/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new module and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from IPFS.
     * @param {InlineObject23} inlineObject23
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportMessagePost: async (
      inlineObject23: InlineObject23,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject23' is not null or undefined
      assertParamExists(
        'modulesImportMessagePost',
        'inlineObject23',
        inlineObject23,
      );
      const localVarPath = `/modules/import/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject23,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the module from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from IPFS.
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportMessagePreviewPost: async (
      inlineObject24: InlineObject24,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject24' is not null or undefined
      assertParamExists(
        'modulesImportMessagePreviewPost',
        'inlineObject24',
        inlineObject24,
      );
      const localVarPath = `/modules/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject24,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns modules menu. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of modules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesMenuGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/modules/menu`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesPost: async (
      module: Module,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'module' is not null or undefined
      assertParamExists('modulesPost', 'module', module);
      const localVarPath = `/modules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        module,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the module with the provided module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the module.
     * @param {string} uuid Module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidDelete: async (
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidDelete', 'uuid', uuid);
      const localVarPath = `/modules/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a zip file containing the published module and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return module and its artifacts in a zip file format for the specified module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidExportFileGet: async (
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidExportFileGet', 'uuid', uuid);
      const localVarPath = `/modules/{uuid}/export/file`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the Hedera message ID for the specified module published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidExportMessageGet: async (
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidExportMessageGet', 'uuid', uuid);
      const localVarPath = `/modules/{uuid}/export/message`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves module configuration.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidGet: async (
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidGet', 'uuid', uuid);
      const localVarPath = `/modules/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the module with the specified (internal) module ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the module onto IPFS.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidPublishPut: async (
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidPublishPut', 'uuid', uuid);
      const localVarPath = `/modules/{uuid}/publish`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates module configuration.
     * @param {string} uuid Selected module ID.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidPut: async (
      uuid: string,
      module: Module,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modulesUuidPut', 'uuid', uuid);
      // verify required parameter 'module' is not null or undefined
      assertParamExists('modulesUuidPut', 'module', module);
      const localVarPath = `/modules/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        module,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validates selected module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesValidatePost: async (
      module: Module,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'module' is not null or undefined
      assertParamExists('modulesValidatePost', 'module', module);
      const localVarPath = `/modules/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        module,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ModulesApi - functional programming interface
 * @export
 */
export const ModulesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ModulesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all modules. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all modules.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modulesGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new module and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesImportFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesImportFilePost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the module from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesImportFilePreviewPost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewModule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesImportFilePreviewPost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new module and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from IPFS.
     * @param {InlineObject23} inlineObject23
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesImportMessagePost(
      inlineObject23: InlineObject23,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesImportMessagePost(
          inlineObject23,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the module from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from IPFS.
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesImportMessagePreviewPost(
      inlineObject24: InlineObject24,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewModule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesImportMessagePreviewPost(
          inlineObject24,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns modules menu. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of modules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesMenuGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Module>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modulesMenuGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesPost(
      module: Module,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modulesPost(
        module,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes the module with the provided module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the module.
     * @param {string} uuid Module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidDelete(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesUuidDelete(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a zip file containing the published module and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return module and its artifacts in a zip file format for the specified module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidExportFileGet(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesUuidExportFileGet(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns the Hedera message ID for the specified module published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidExportMessageGet(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportModule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesUuidExportMessageGet(
          uuid,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves module configuration.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidGet(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modulesUuidGet(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the module with the specified (internal) module ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the module onto IPFS.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidPublishPut(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishModule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesUuidPublishPut(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates module configuration.
     * @param {string} uuid Selected module ID.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesUuidPut(
      uuid: string,
      module: Module,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modulesUuidPut(
        uuid,
        module,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Validates selected module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modulesValidatePost(
      module: Module,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateModule>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.modulesValidatePost(module, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ModulesApi - factory interface
 * @export
 */
export const ModulesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ModulesApiFp(configuration);
  return {
    /**
     * Returns all modules. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all modules.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Module> {
      return localVarFp
        .modulesGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new module and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportFilePost(body: any, options?: any): AxiosPromise<Module> {
      return localVarFp
        .modulesImportFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the module from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from a zip file.
     * @param {any} body A zip file that contains the module and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportFilePreviewPost(
      body: any,
      options?: any,
    ): AxiosPromise<PreviewModule> {
      return localVarFp
        .modulesImportFilePreviewPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new module and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new module from IPFS.
     * @param {InlineObject23} inlineObject23
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportMessagePost(
      inlineObject23: InlineObject23,
      options?: any,
    ): AxiosPromise<Module> {
      return localVarFp
        .modulesImportMessagePost(inlineObject23, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the module from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Module preview from IPFS.
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesImportMessagePreviewPost(
      inlineObject24: InlineObject24,
      options?: any,
    ): AxiosPromise<PreviewModule> {
      return localVarFp
        .modulesImportMessagePreviewPost(inlineObject24, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns modules menu. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of modules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesMenuGet(options?: any): AxiosPromise<Array<Module>> {
      return localVarFp
        .modulesMenuGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesPost(module: Module, options?: any): AxiosPromise<void> {
      return localVarFp
        .modulesPost(module, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the module with the provided module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the module.
     * @param {string} uuid Module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidDelete(uuid: string, options?: any): AxiosPromise<boolean> {
      return localVarFp
        .modulesUuidDelete(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a zip file containing the published module and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return module and its artifacts in a zip file format for the specified module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidExportFileGet(uuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .modulesUuidExportFileGet(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the Hedera message ID for the specified module published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published module.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidExportMessageGet(
      uuid: string,
      options?: any,
    ): AxiosPromise<ExportModule> {
      return localVarFp
        .modulesUuidExportMessageGet(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves module configuration.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidGet(uuid: string, options?: any): AxiosPromise<Module> {
      return localVarFp
        .modulesUuidGet(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the module with the specified (internal) module ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the module onto IPFS.
     * @param {string} uuid Selected module ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidPublishPut(
      uuid: string,
      options?: any,
    ): AxiosPromise<PublishModule> {
      return localVarFp
        .modulesUuidPublishPut(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates module configuration.
     * @param {string} uuid Selected module ID.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesUuidPut(
      uuid: string,
      module: Module,
      options?: any,
    ): AxiosPromise<Module> {
      return localVarFp
        .modulesUuidPut(uuid, module, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validates selected module. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates module.
     * @param {Module} module Object that contains module configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modulesValidatePost(
      module: Module,
      options?: any,
    ): AxiosPromise<ValidateModule> {
      return localVarFp
        .modulesValidatePost(module, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ModulesApi - object-oriented interface
 * @export
 * @class ModulesApi
 * @extends {BaseAPI}
 */
export class ModulesApi extends BaseAPI {
  /**
   * Returns all modules. Only users with the Standard Registry and Installer role are allowed to make the request.
   * @summary Return a list of all modules.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ModulesApiFp(this.configuration)
      .modulesGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new module and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new module from a zip file.
   * @param {any} body A zip file that contains the module and associated schemas and VCs to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesImportFilePost(body: any, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesImportFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the module from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Module preview from a zip file.
   * @param {any} body A zip file that contains the module and associated schemas and VCs to be viewed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesImportFilePreviewPost(body: any, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesImportFilePreviewPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new module and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new module from IPFS.
   * @param {InlineObject23} inlineObject23
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesImportMessagePost(
    inlineObject23: InlineObject23,
    options?: AxiosRequestConfig,
  ) {
    return ModulesApiFp(this.configuration)
      .modulesImportMessagePost(inlineObject23, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the module from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Module preview from IPFS.
   * @param {InlineObject24} inlineObject24
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesImportMessagePreviewPost(
    inlineObject24: InlineObject24,
    options?: AxiosRequestConfig,
  ) {
    return ModulesApiFp(this.configuration)
      .modulesImportMessagePreviewPost(inlineObject24, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns modules menu. Only users with the Standard Registry and Installer role are allowed to make the request.
   * @summary Return a list of modules.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesMenuGet(options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesMenuGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new module. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates a new module.
   * @param {Module} module Object that contains module configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesPost(module: Module, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesPost(module, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the module with the provided module ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Deletes the module.
   * @param {string} uuid Module ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidDelete(uuid: string, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesUuidDelete(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a zip file containing the published module and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return module and its artifacts in a zip file format for the specified module.
   * @param {string} uuid Selected module ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidExportFileGet(uuid: string, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesUuidExportFileGet(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the Hedera message ID for the specified module published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return Heder message ID for the specified published module.
   * @param {string} uuid Selected module ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidExportMessageGet(
    uuid: string,
    options?: AxiosRequestConfig,
  ) {
    return ModulesApiFp(this.configuration)
      .modulesUuidExportMessageGet(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Retrieves module configuration.
   * @param {string} uuid Selected module ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidGet(uuid: string, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesUuidGet(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the module with the specified (internal) module ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the module onto IPFS.
   * @param {string} uuid Selected module ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidPublishPut(uuid: string, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesUuidPublishPut(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates module configuration for the specified module ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Updates module configuration.
   * @param {string} uuid Selected module ID.
   * @param {Module} module Object that contains module configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesUuidPut(
    uuid: string,
    module: Module,
    options?: AxiosRequestConfig,
  ) {
    return ModulesApiFp(this.configuration)
      .modulesUuidPut(uuid, module, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validates selected module. Only users with the Standard Registry role are allowed to make the request.
   * @summary Validates module.
   * @param {Module} module Object that contains module configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModulesApi
   */
  public modulesValidatePost(module: Module, options?: AxiosRequestConfig) {
    return ModulesApiFp(this.configuration)
      .modulesValidatePost(module, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all policies. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePost: async (
      body: any,
      versionOfTopicId?: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesImportFilePost', 'body', body);
      const localVarPath = `/policies/import/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (versionOfTopicId !== undefined) {
        localVarQueryParameter['versionOfTopicId'] = versionOfTopicId;
      }

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePreviewPost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesImportFilePreviewPost', 'body', body);
      const localVarPath = `/policies/import/file/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject10} inlineObject10
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePost: async (
      inlineObject10: InlineObject10,
      versionOfTopicId?: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject10' is not null or undefined
      assertParamExists(
        'policiesImportMessagePost',
        'inlineObject10',
        inlineObject10,
      );
      const localVarPath = `/policies/import/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (versionOfTopicId !== undefined) {
        localVarQueryParameter['versionOfTopicId'] = versionOfTopicId;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject10,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject12} inlineObject12
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePreviewPost: async (
      inlineObject12: InlineObject12,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject12' is not null or undefined
      assertParamExists(
        'policiesImportMessagePreviewPost',
        'inlineObject12',
        inlineObject12,
      );
      const localVarPath = `/policies/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject12,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns data from the root policy block. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/blocks`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidGet: async (
      policyId: string,
      uuid: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidGet', 'policyId', policyId);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidGet', 'uuid', uuid);
      const localVarPath = `/policies/{policyId}/blocks/{uuid}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidPost: async (
      policyId: string,
      uuid: string,
      body: object,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'policyId', policyId);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'uuid', uuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'body', body);
      const localVarPath = `/policies/{policyId}/blocks/{uuid}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return policy to editing. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy to editing.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDraftPut: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdDraftPut', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/draft`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunArtifactsGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdDryRunArtifactsGet',
        'policyId',
        policyId,
      );
      const localVarPath = `/policies/{policyId}/dry-run/artifacts`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunIpfsGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdDryRunIpfsGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/dry-run/ipfs`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Logs virtual user into the system. Only users with the Standard Registry role are allowed to make the request.
     * @summary Logs virtual user into the system.
     * @param {string} policyId Policy ID.
     * @param {InlineObject14} inlineObject14
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunLoginPost: async (
      policyId: string,
      inlineObject14: InlineObject14,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdDryRunLoginPost',
        'policyId',
        policyId,
      );
      // verify required parameter 'inlineObject14' is not null or undefined
      assertParamExists(
        'policiesPolicyIdDryRunLoginPost',
        'inlineObject14',
        inlineObject14,
      );
      const localVarPath = `/policies/{policyId}/dry-run/login`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject14,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run policy without making any persistent changes or executing transaction. Only users with the Standard Registry role are allowed to make the request.
     * @summary Dry Run policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunPut: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdDryRunPut', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/dry-run`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Restarts the execution of the policy. Clear data in database. Only users with the Standard Registry role are allowed to make the request.
     * @summary Restarts the execution of the policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunRestartPost: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdDryRunRestartPost',
        'policyId',
        policyId,
      );
      const localVarPath = `/policies/{policyId}/dry-run/restart`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns lists of virtual transactions. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual transactions.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunTransactionsGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdDryRunTransactionsGet',
        'policyId',
        policyId,
      );
      const localVarPath = `/policies/{policyId}/dry-run/transactions`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new virtual account. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create a new virtual account.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunUserPost: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdDryRunUserPost', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/dry-run/user`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all virtual users. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all virtual users.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunUsersGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdDryRunUsersGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/dry-run/users`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportFileGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdExportFileGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/export/file`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportMessageGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdExportMessageGet',
        'policyId',
        policyId,
      );
      const localVarPath = `/policies/{policyId}/export/message`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of groups the user is a member of.
     * @summary Returns a list of groups the user is a member of.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGroupsGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdGroupsGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/groups`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Makes the selected group active. if UUID is not set then returns the user to the default state.
     * @summary Makes the selected group active.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject9} inlineObject9
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGroupsPost: async (
      policyId: string,
      inlineObject9: InlineObject9,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdGroupsPost', 'policyId', policyId);
      // verify required parameter 'inlineObject9' is not null or undefined
      assertParamExists(
        'policiesPolicyIdGroupsPost',
        'inlineObject9',
        inlineObject9,
      );
      const localVarPath = `/policies/{policyId}/groups`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject9,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests Multi policy config.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdMultipleGet: async (
      policyId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdMultipleGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/multiple`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a link between the current policy and the main policy. Or creates a group making the current policy the main one.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {InlineObject15} inlineObject15
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdMultiplePost: async (
      policyId: string,
      inlineObject15: InlineObject15,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdMultiplePost', 'policyId', policyId);
      // verify required parameter 'inlineObject15' is not null or undefined
      assertParamExists(
        'policiesPolicyIdMultiplePost',
        'inlineObject15',
        inlineObject15,
      );
      const localVarPath = `/policies/{policyId}/multiple`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject15,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject7} inlineObject7
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPublishPut: async (
      policyId: string,
      inlineObject7: InlineObject7,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdPublishPut', 'policyId', policyId);
      // verify required parameter 'inlineObject7' is not null or undefined
      assertParamExists(
        'policiesPolicyIdPublishPut',
        'inlineObject7',
        inlineObject7,
      );
      const localVarPath = `/policies/{policyId}/publish`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject7,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPut: async (
      policyId: string,
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdPut', 'policyId', policyId);
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesPolicyIdPut', 'policyConfig', policyConfig);
      const localVarPath = `/policies/{policyId}`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagBlocksGet: async (
      policyId: string,
      tag: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdTagTagBlocksGet',
        'policyId',
        policyId,
      );
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagBlocksGet', 'tag', tag);
      const localVarPath = `/policies/{policyId}/tag/{tag}/blocks`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests block data by tag. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagBlocksPost: async (
      policyId: string,
      tag: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdTagTagBlocksPost',
        'policyId',
        policyId,
      );
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagBlocksPost', 'tag', tag);
      const localVarPath = `/policies/{policyId}/tag/{tag}/blocks`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Standard Registry and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagGet: async (
      policyId: string,
      tag: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagGet', 'policyId', policyId);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagGet', 'tag', tag);
      const localVarPath = `/policies/{policyId}/tag/{tag}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPost: async (
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesPost', 'policyConfig', policyConfig);
      const localVarPath = `/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportFilePost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesPushImportFilePost', 'body', body);
      const localVarPath = `/policies/push/import/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts from IPFS into the local DB.
     * @param {InlineObject11} inlineObject11
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportMessagePost: async (
      inlineObject11: InlineObject11,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject11' is not null or undefined
      assertParamExists(
        'policiesPushImportMessagePost',
        'inlineObject11',
        inlineObject11,
      );
      const localVarPath = `/policies/push/import/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject11,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Previews the policy from IPFS without loading it into the local DB.
     * @param {InlineObject13} inlineObject13
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportMessagePreviewPost: async (
      inlineObject13: InlineObject13,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject13' is not null or undefined
      assertParamExists(
        'policiesPushImportMessagePreviewPost',
        'inlineObject13',
        inlineObject13,
      );
      const localVarPath = `/policies/push/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject13,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic.
     * @param {string} policyId Policy ID.
     * @param {InlineObject8} inlineObject8
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushPolicyIdPublishPut: async (
      policyId: string,
      inlineObject8: InlineObject8,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPushPolicyIdPublishPut', 'policyId', policyId);
      // verify required parameter 'inlineObject8' is not null or undefined
      assertParamExists(
        'policiesPushPolicyIdPublishPut',
        'inlineObject8',
        inlineObject8,
      );
      const localVarPath = `/policies/push/{policyId}/publish`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject8,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushPost: async (
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesPushPost', 'policyConfig', policyConfig);
      const localVarPath = `/policies/push`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validates selected policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesValidatePost: async (
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesValidatePost', 'policyConfig', policyConfig);
      const localVarPath = `/policies/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all policies. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.policiesGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportFilePost(
      body: any,
      versionOfTopicId?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportFilePost(
          body,
          versionOfTopicId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportFilePreviewPost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportFilePreviewPost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject10} inlineObject10
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportMessagePost(
      inlineObject10: InlineObject10,
      versionOfTopicId?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportMessagePost(
          inlineObject10,
          versionOfTopicId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject12} inlineObject12
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportMessagePreviewPost(
      inlineObject12: InlineObject12,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportMessagePreviewPost(
          inlineObject12,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns data from the root policy block. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyBlock>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksUuidGet(
      policyId: string,
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PolicyBlockData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidGet(
          policyId,
          uuid,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksUuidPost(
      policyId: string,
      uuid: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidPost(
          policyId,
          uuid,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Return policy to editing. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy to editing.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDraftPut(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDraftPut(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunArtifactsGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse2004>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunArtifactsGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunIpfsGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse2005>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunIpfsGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Logs virtual user into the system. Only users with the Standard Registry role are allowed to make the request.
     * @summary Logs virtual user into the system.
     * @param {string} policyId Policy ID.
     * @param {InlineObject14} inlineObject14
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunLoginPost(
      policyId: string,
      inlineObject14: InlineObject14,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse200User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunLoginPost(
          policyId,
          inlineObject14,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Run policy without making any persistent changes or executing transaction. Only users with the Standard Registry role are allowed to make the request.
     * @summary Dry Run policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunPut(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunPut(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Restarts the execution of the policy. Clear data in database. Only users with the Standard Registry role are allowed to make the request.
     * @summary Restarts the execution of the policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunRestartPost(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunRestartPost(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns lists of virtual transactions. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual transactions.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunTransactionsGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse2003>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunTransactionsGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Create a new virtual account. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create a new virtual account.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunUserPost(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse200User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunUserPost(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all virtual users. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all virtual users.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdDryRunUsersGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse200User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdDryRunUsersGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdExportFileGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdExportFileGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdExportMessageGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdExportMessageGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PolicyConfig & object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdGet(policyId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a list of groups the user is a member of.
     * @summary Returns a list of groups the user is a member of.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdGroupsGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<InlineResponse2001>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdGroupsGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Makes the selected group active. if UUID is not set then returns the user to the default state.
     * @summary Makes the selected group active.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject9} inlineObject9
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdGroupsPost(
      policyId: string,
      inlineObject9: InlineObject9,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdGroupsPost(
          policyId,
          inlineObject9,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests Multi policy config.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdMultipleGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiPolicyConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdMultipleGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a link between the current policy and the main policy. Or creates a group making the current policy the main one.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {InlineObject15} inlineObject15
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdMultiplePost(
      policyId: string,
      inlineObject15: InlineObject15,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiPolicyConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdMultiplePost(
          policyId,
          inlineObject15,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject7} inlineObject7
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdPublishPut(
      policyId: string,
      inlineObject7: InlineObject7,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdPublishPut(
          policyId,
          inlineObject7,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdPut(
      policyId: string,
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdPut(
          policyId,
          policyConfig,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdTagTagBlocksGet(
      policyId: string,
      tag: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdTagTagBlocksGet(
          policyId,
          tag,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests block data by tag. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdTagTagBlocksPost(
      policyId: string,
      tag: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PolicyBlockData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdTagTagBlocksPost(
          policyId,
          tag,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Standard Registry and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdTagTagGet(
      policyId: string,
      tag: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdTagTagGet(
          policyId,
          tag,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPost(
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPost(
        policyConfig,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPushImportFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPushImportFilePost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts from IPFS into the local DB.
     * @param {InlineObject11} inlineObject11
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPushImportMessagePost(
      inlineObject11: InlineObject11,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPushImportMessagePost(
          inlineObject11,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Previews the policy from IPFS without loading it into the local DB.
     * @param {InlineObject13} inlineObject13
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPushImportMessagePreviewPost(
      inlineObject13: InlineObject13,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPushImportMessagePreviewPost(
          inlineObject13,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic.
     * @param {string} policyId Policy ID.
     * @param {InlineObject8} inlineObject8
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPushPolicyIdPublishPut(
      policyId: string,
      inlineObject8: InlineObject8,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPushPolicyIdPublishPut(
          policyId,
          inlineObject8,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPushPost(
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPushPost(policyConfig, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Validates selected policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesValidatePost(
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatePolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesValidatePost(
          policyConfig,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PoliciesApiFp(configuration);
  return {
    /**
     * Returns all policies. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig & object>> {
      return localVarFp
        .policiesGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePost(
      body: any,
      versionOfTopicId?: string,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig>> {
      return localVarFp
        .policiesImportFilePost(body, versionOfTopicId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePreviewPost(
      body: any,
      options?: any,
    ): AxiosPromise<PreviewPolicy> {
      return localVarFp
        .policiesImportFilePreviewPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject10} inlineObject10
     * @param {string} [versionOfTopicId] The topic ID of policy version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePost(
      inlineObject10: InlineObject10,
      versionOfTopicId?: string,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig>> {
      return localVarFp
        .policiesImportMessagePost(inlineObject10, versionOfTopicId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject12} inlineObject12
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePreviewPost(
      inlineObject12: InlineObject12,
      options?: any,
    ): AxiosPromise<PreviewPolicy> {
      return localVarFp
        .policiesImportMessagePreviewPost(inlineObject12, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns data from the root policy block. Only users with the Standard Registry and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<PolicyBlock> {
      return localVarFp
        .policiesPolicyIdBlocksGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidGet(
      policyId: string,
      uuid: string,
      options?: any,
    ): AxiosPromise<PolicyBlockData> {
      return localVarFp
        .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidPost(
      policyId: string,
      uuid: string,
      body: object,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return policy to editing. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy to editing.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDraftPut(
      policyId: string,
      options?: any,
    ): AxiosPromise<PublishPolicy> {
      return localVarFp
        .policiesPolicyIdDraftPut(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunArtifactsGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse2004>> {
      return localVarFp
        .policiesPolicyIdDryRunArtifactsGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual artifacts.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunIpfsGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse2005>> {
      return localVarFp
        .policiesPolicyIdDryRunIpfsGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Logs virtual user into the system. Only users with the Standard Registry role are allowed to make the request.
     * @summary Logs virtual user into the system.
     * @param {string} policyId Policy ID.
     * @param {InlineObject14} inlineObject14
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunLoginPost(
      policyId: string,
      inlineObject14: InlineObject14,
      options?: any,
    ): AxiosPromise<Array<InlineResponse200User>> {
      return localVarFp
        .policiesPolicyIdDryRunLoginPost(policyId, inlineObject14, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Run policy without making any persistent changes or executing transaction. Only users with the Standard Registry role are allowed to make the request.
     * @summary Dry Run policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunPut(
      policyId: string,
      options?: any,
    ): AxiosPromise<PublishPolicy> {
      return localVarFp
        .policiesPolicyIdDryRunPut(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Restarts the execution of the policy. Clear data in database. Only users with the Standard Registry role are allowed to make the request.
     * @summary Restarts the execution of the policy.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunRestartPost(
      policyId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPolicyIdDryRunRestartPost(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns lists of virtual transactions. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns lists of virtual transactions.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunTransactionsGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse2003>> {
      return localVarFp
        .policiesPolicyIdDryRunTransactionsGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new virtual account. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create a new virtual account.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunUserPost(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse200User>> {
      return localVarFp
        .policiesPolicyIdDryRunUserPost(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all virtual users. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all virtual users.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdDryRunUsersGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse200User>> {
      return localVarFp
        .policiesPolicyIdDryRunUsersGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportFileGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<ExportPolicy> {
      return localVarFp
        .policiesPolicyIdExportFileGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportMessageGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<ExportPolicy> {
      return localVarFp
        .policiesPolicyIdExportMessageGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<PolicyConfig & object> {
      return localVarFp
        .policiesPolicyIdGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of groups the user is a member of.
     * @summary Returns a list of groups the user is a member of.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGroupsGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<Array<InlineResponse2001>> {
      return localVarFp
        .policiesPolicyIdGroupsGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Makes the selected group active. if UUID is not set then returns the user to the default state.
     * @summary Makes the selected group active.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject9} inlineObject9
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGroupsPost(
      policyId: string,
      inlineObject9: InlineObject9,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPolicyIdGroupsPost(policyId, inlineObject9, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests Multi policy config.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdMultipleGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<MultiPolicyConfig> {
      return localVarFp
        .policiesPolicyIdMultipleGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a link between the current policy and the main policy. Or creates a group making the current policy the main one.
     * @summary Requests Multi policy config.
     * @param {string} policyId Policy ID.
     * @param {InlineObject15} inlineObject15
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdMultiplePost(
      policyId: string,
      inlineObject15: InlineObject15,
      options?: any,
    ): AxiosPromise<MultiPolicyConfig> {
      return localVarFp
        .policiesPolicyIdMultiplePost(policyId, inlineObject15, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject7} inlineObject7
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPublishPut(
      policyId: string,
      inlineObject7: InlineObject7,
      options?: any,
    ): AxiosPromise<PublishPolicy> {
      return localVarFp
        .policiesPolicyIdPublishPut(policyId, inlineObject7, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPut(
      policyId: string,
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<PolicyConfig> {
      return localVarFp
        .policiesPolicyIdPut(policyId, policyConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagBlocksGet(
      policyId: string,
      tag: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPolicyIdTagTagBlocksGet(policyId, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests block data by tag. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagBlocksPost(
      policyId: string,
      tag: string,
      options?: any,
    ): AxiosPromise<PolicyBlockData> {
      return localVarFp
        .policiesPolicyIdTagTagBlocksPost(policyId, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Standard Registry and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagGet(
      policyId: string,
      tag: string,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .policiesPolicyIdTagTagGet(policyId, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPost(
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPost(policyConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportFilePost(body: any, options?: any): AxiosPromise<Task> {
      return localVarFp
        .policiesPushImportFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new policy and all associated artifacts from IPFS into the local DB.
     * @param {InlineObject11} inlineObject11
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportMessagePost(
      inlineObject11: InlineObject11,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .policiesPushImportMessagePost(inlineObject11, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Previews the policy from IPFS without loading it into the local DB.
     * @param {InlineObject13} inlineObject13
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushImportMessagePreviewPost(
      inlineObject13: InlineObject13,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .policiesPushImportMessagePreviewPost(inlineObject13, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic.
     * @param {string} policyId Policy ID.
     * @param {InlineObject8} inlineObject8
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushPolicyIdPublishPut(
      policyId: string,
      inlineObject8: InlineObject8,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .policiesPushPolicyIdPublishPut(policyId, inlineObject8, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPushPost(
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .policiesPushPost(policyConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validates selected policy. Only users with the Standard Registry role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesValidatePost(
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<ValidatePolicy> {
      return localVarFp
        .policiesValidatePost(policyConfig, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
  /**
   * Returns all policies. Only users with the Standard Registry and Installer role are allowed to make the request.
   * @summary Return a list of all policies.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new policy from a zip file.
   * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
   * @param {string} [versionOfTopicId] The topic ID of policy version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportFilePost(
    body: any,
    versionOfTopicId?: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportFilePost(body, versionOfTopicId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the policy from a zip file without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Policy preview from a zip file.
   * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportFilePreviewPost(
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportFilePreviewPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new policy from IPFS.
   * @param {InlineObject10} inlineObject10
   * @param {string} [versionOfTopicId] The topic ID of policy version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportMessagePost(
    inlineObject10: InlineObject10,
    versionOfTopicId?: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportMessagePost(inlineObject10, versionOfTopicId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Policy preview from IPFS.
   * @param {InlineObject12} inlineObject12
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportMessagePreviewPost(
    inlineObject12: InlineObject12,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportMessagePreviewPost(inlineObject12, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns data from the root policy block. Only users with the Standard Registry and Installer role are allowed to make the request.
   * @summary Retrieves data for the policy root block.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests block data. Only users with a role that described in block are allowed to make the request.
   * @summary Requests block data.
   * @param {string} policyId Selected policy ID.
   * @param {string} uuid Selected block UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksUuidGet(
    policyId: string,
    uuid: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sends data to the specified block.
   * @summary Sends data to the specified block.
   * @param {string} policyId Selected policy ID.
   * @param {string} uuid Selected block UUID.
   * @param {object} body Object with the data to be sent to the block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksUuidPost(
    policyId: string,
    uuid: string,
    body: object,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return policy to editing. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return policy to editing.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDraftPut(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDraftPut(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns lists of virtual artifacts.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunArtifactsGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunArtifactsGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns lists of virtual artifacts. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns lists of virtual artifacts.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunIpfsGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunIpfsGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Logs virtual user into the system. Only users with the Standard Registry role are allowed to make the request.
   * @summary Logs virtual user into the system.
   * @param {string} policyId Policy ID.
   * @param {InlineObject14} inlineObject14
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunLoginPost(
    policyId: string,
    inlineObject14: InlineObject14,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunLoginPost(policyId, inlineObject14, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Run policy without making any persistent changes or executing transaction. Only users with the Standard Registry role are allowed to make the request.
   * @summary Dry Run policy.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunPut(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunPut(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Restarts the execution of the policy. Clear data in database. Only users with the Standard Registry role are allowed to make the request.
   * @summary Restarts the execution of the policy.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunRestartPost(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunRestartPost(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns lists of virtual transactions. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns lists of virtual transactions.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunTransactionsGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunTransactionsGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new virtual account. Only users with the Standard Registry role are allowed to make the request.
   * @summary Create a new virtual account.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunUserPost(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunUserPost(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all virtual users. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns all virtual users.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdDryRunUsersGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdDryRunUsersGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return policy and its artifacts in a zip file format for the specified policy.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdExportFileGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdExportFileGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return Heder message ID for the specified published policy.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdExportMessageGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdExportMessageGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Retrieves policy configuration.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdGet(policyId: string, options?: AxiosRequestConfig) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of groups the user is a member of.
   * @summary Returns a list of groups the user is a member of.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdGroupsGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdGroupsGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Makes the selected group active. if UUID is not set then returns the user to the default state.
   * @summary Makes the selected group active.
   * @param {string} policyId Selected policy ID.
   * @param {InlineObject9} inlineObject9
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdGroupsPost(
    policyId: string,
    inlineObject9: InlineObject9,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdGroupsPost(policyId, inlineObject9, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests Multi policy config.
   * @summary Requests Multi policy config.
   * @param {string} policyId Policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdMultipleGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdMultipleGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a link between the current policy and the main policy. Or creates a group making the current policy the main one.
   * @summary Requests Multi policy config.
   * @param {string} policyId Policy ID.
   * @param {InlineObject15} inlineObject15
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdMultiplePost(
    policyId: string,
    inlineObject15: InlineObject15,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdMultiplePost(policyId, inlineObject15, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the policy onto IPFS.
   * @param {string} policyId Selected policy ID.
   * @param {InlineObject7} inlineObject7
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdPublishPut(
    policyId: string,
    inlineObject7: InlineObject7,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdPublishPut(policyId, inlineObject7, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates policy configuration for the specified policy ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Updates policy configuration.
   * @param {string} policyId Selected policy ID.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdPut(
    policyId: string,
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdPut(policyId, policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sends data to the specified block.
   * @summary Sends data to the specified block.
   * @param {string} policyId Policy ID.
   * @param {string} tag Tag from the selected policy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdTagTagBlocksGet(
    policyId: string,
    tag: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdTagTagBlocksGet(policyId, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests block data by tag. Only users with a role that described in block are allowed to make the request.
   * @summary Requests block data.
   * @param {string} policyId Policy ID.
   * @param {string} tag Tag from the selected policy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdTagTagBlocksPost(
    policyId: string,
    tag: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdTagTagBlocksPost(policyId, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests block ID from a policy by tag. Only users with the Standard Registry and Installer roles are allowed to make the request.
   * @summary Requests block ID from a policy by tag.
   * @param {string} policyId Selected policy ID.
   * @param {string} tag Tag from the selected policy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdTagTagGet(
    policyId: string,
    tag: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdTagTagGet(policyId, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates a new policy.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPost(
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPost(policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB.
   * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPushImportFilePost(body: any, options?: AxiosRequestConfig) {
    return PoliciesApiFp(this.configuration)
      .policiesPushImportFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new policy and all associated artifacts from IPFS into the local DB.
   * @param {InlineObject11} inlineObject11
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPushImportMessagePost(
    inlineObject11: InlineObject11,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPushImportMessagePost(inlineObject11, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the policy from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Previews the policy from IPFS without loading it into the local DB.
   * @param {InlineObject13} inlineObject13
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPushImportMessagePreviewPost(
    inlineObject13: InlineObject13,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPushImportMessagePreviewPost(inlineObject13, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic.
   * @param {string} policyId Policy ID.
   * @param {InlineObject8} inlineObject8
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPushPolicyIdPublishPut(
    policyId: string,
    inlineObject8: InlineObject8,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPushPolicyIdPublishPut(policyId, inlineObject8, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new policy. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates a new policy.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPushPost(
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPushPost(policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validates selected policy. Only users with the Standard Registry role are allowed to make the request.
   * @summary Validates policy.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesValidatePost(
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesValidatePost(policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Sets Hedera credentials for the user
     * @summary Sets Hedera credentials for the user
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPushUsernamePut: async (
      username: string,
      user: User,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesPushUsernamePut', 'username', username);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('profilesPushUsernamePut', 'user', user);
      const localVarPath = `/profiles/push/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameBalanceGet: async (
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernameBalanceGet', 'username', username);
      const localVarPath = `/profiles/{username}/balance`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user account information. For users with the Standard Registry role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameGet: async (
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernameGet', 'username', username);
      const localVarPath = `/profiles/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets Hedera credentials for the user. For users with the Standard Registry role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernamePut: async (
      username: string,
      user: User,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernamePut', 'username', username);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('profilesUsernamePut', 'user', user);
      const localVarPath = `/profiles/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Sets Hedera credentials for the user
     * @summary Sets Hedera credentials for the user
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesPushUsernamePut(
      username: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesPushUsernamePut(
          username,
          user,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernameBalanceGet(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernameBalanceGet(
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user account information. For users with the Standard Registry role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernameGet(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernameGet(username, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sets Hedera credentials for the user. For users with the Standard Registry role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernamePut(
      username: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernamePut(
          username,
          user,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfilesApiFp(configuration);
  return {
    /**
     * Sets Hedera credentials for the user
     * @summary Sets Hedera credentials for the user
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPushUsernamePut(
      username: string,
      user: User,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .profilesPushUsernamePut(username, user, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameBalanceGet(
      username: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .profilesUsernameBalanceGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user account information. For users with the Standard Registry role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameGet(username: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .profilesUsernameGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets Hedera credentials for the user. For users with the Standard Registry role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernamePut(
      username: string,
      user: User,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .profilesUsernamePut(username, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
  /**
   * Sets Hedera credentials for the user
   * @summary Sets Hedera credentials for the user
   * @param {string} username The name of the user for whom to update the information.
   * @param {User} user Object that contains the Hedera account data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesPushUsernamePut(
    username: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .profilesPushUsernamePut(username, user, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
   * @summary Returns user\'s Hedera account balance.
   * @param {string} username The name of the user for whom to fetch the balance.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernameBalanceGet(
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernameBalanceGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user account information. For users with the Standard Registry role it also returns address book and VC document information.
   * @summary Returns user account info.
   * @param {string} username The name of the user for whom to fetch the information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernameGet(username: string, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernameGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets Hedera credentials for the user. For users with the Standard Registry role it also creates an address book.
   * @summary Sets Hedera credentials for the user.
   * @param {string} username The name of the user for whom to update the information.
   * @param {User} user Object that contains the Hedera account data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernamePut(
    username: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernamePut(username, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns schema by schema ID.
     * @summary Returns schema by schema ID.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemaSchemaIdGet: async (
      schemaId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemaSchemaIdGet', 'schemaId', schemaId);
      const localVarPath = `/schema/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns schema by schema ID.
     * @summary Returns schema by schema ID.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemaSchemaIdGet(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemaSchemaIdGet(schemaId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SchemaApiFp(configuration);
  return {
    /**
     * Returns schema by schema ID.
     * @summary Returns schema by schema ID.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemaSchemaIdGet(schemaId: string, options?: any): AxiosPromise<Schema> {
      return localVarFp
        .schemaSchemaIdGet(schemaId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
  /**
   * Returns schema by schema ID.
   * @summary Returns schema by schema ID.
   * @param {string} schemaId Schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemaApi
   */
  public schemaSchemaIdGet(schemaId: string, options?: AxiosRequestConfig) {
    return SchemaApiFp(this.configuration)
      .schemaSchemaIdGet(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SchemasApi - axios parameter creator
 * @export
 */
export const SchemasApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/schemas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the schema from a zip file. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportFilePreviewPost: async (
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasImportFilePreviewPost', 'body', body);
      const localVarPath = `/schemas/import/file/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportMessagePreviewPost: async (
      inlineObject4: InlineObject4,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject4' is not null or undefined
      assertParamExists(
        'schemasImportMessagePreviewPost',
        'inlineObject4',
        inlineObject4,
      );
      const localVarPath = `/schemas/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushImportMessagePreviewPost: async (
      inlineObject5: InlineObject5,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject5' is not null or undefined
      assertParamExists(
        'schemasPushImportMessagePreviewPost',
        'inlineObject5',
        inlineObject5,
      );
      const localVarPath = `/schemas/push/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushSchemaIdPublishPut: async (
      schemaId: string,
      inlineObject1: InlineObject1,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasPushSchemaIdPublishPut', 'schemaId', schemaId);
      // verify required parameter 'inlineObject1' is not null or undefined
      assertParamExists(
        'schemasPushSchemaIdPublishPut',
        'inlineObject1',
        inlineObject1,
      );
      const localVarPath = `/schemas/push/{schemaId}/publish`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdImportFilePost: async (
      topicId: string,
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasPushTopicIdImportFilePost', 'topicId', topicId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasPushTopicIdImportFilePost', 'body', body);
      const localVarPath = `/schemas/push/{topicId}/import/file`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdImportMessagePost: async (
      topicId: string,
      inlineObject3: InlineObject3,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists(
        'schemasPushTopicIdImportMessagePost',
        'topicId',
        topicId,
      );
      // verify required parameter 'inlineObject3' is not null or undefined
      assertParamExists(
        'schemasPushTopicIdImportMessagePost',
        'inlineObject3',
        inlineObject3,
      );
      const localVarPath = `/schemas/push/{topicId}/import/message`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject3,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdPost: async (
      topicId: string,
      schema: Schema,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasPushTopicIdPost', 'topicId', topicId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasPushTopicIdPost', 'schema', schema);
      const localVarPath = `/schemas/push/{topicId}`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdDelete: async (
      schemaId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdDelete', 'schemaId', schemaId);
      const localVarPath = `/schemas/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns schema files for the schemas. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportFilePost: async (
      schemaId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdExportFilePost', 'schemaId', schemaId);
      const localVarPath = `/schemas/{schemaId}/export/file`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Standard Registry role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportMessagePost: async (
      schemaId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists(
        'schemasSchemaIdExportMessagePost',
        'schemaId',
        schemaId,
      );
      const localVarPath = `/schemas/{schemaId}/export/message`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPublishPut: async (
      schemaId: string,
      inlineObject: InlineObject,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdPublishPut', 'schemaId', schemaId);
      // verify required parameter 'inlineObject' is not null or undefined
      assertParamExists(
        'schemasSchemaIdPublishPut',
        'inlineObject',
        inlineObject,
      );
      const localVarPath = `/schemas/{schemaId}/publish`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPut: async (
      schemaId: string,
      schema: Schema,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdPut', 'schemaId', schemaId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasSchemaIdPut', 'schema', schema);
      const localVarPath = `/schemas/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Finds the schema using the schema type.
     * @summary Returns schema by schema type.
     * @param {'STANDARD_REGISTRY' | 'USER' | 'POLICY' | 'MINT_TOKEN' | 'WIPE_TOKEN' | 'MINT_NFTOKEN'} schemaEntity schema type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemEntitySchemaEntityGet: async (
      schemaEntity:
        | 'STANDARD_REGISTRY'
        | 'USER'
        | 'POLICY'
        | 'MINT_TOKEN'
        | 'WIPE_TOKEN'
        | 'MINT_NFTOKEN',
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaEntity' is not null or undefined
      assertParamExists(
        'schemasSystemEntitySchemaEntityGet',
        'schemaEntity',
        schemaEntity,
      );
      const localVarPath = `/schemas/system/entity/{schemaEntity}`.replace(
        `{${'schemaEntity'}}`,
        encodeURIComponent(String(schemaEntity)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Makes the selected scheme active. Other schemes of the same type become inactive. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdActivePut: async (
      schemaId: string,
      inlineObject6: InlineObject6,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSystemSchemaIdActivePut', 'schemaId', schemaId);
      // verify required parameter 'inlineObject6' is not null or undefined
      assertParamExists(
        'schemasSystemSchemaIdActivePut',
        'inlineObject6',
        inlineObject6,
      );
      const localVarPath = `/schemas/system/{schemaId}/active`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject6,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdDelete: async (
      schemaId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSystemSchemaIdDelete', 'schemaId', schemaId);
      const localVarPath = `/schemas/system/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdPut: async (
      schemaId: string,
      schema: Schema,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSystemSchemaIdPut', 'schemaId', schemaId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasSystemSchemaIdPut', 'schema', schema);
      const localVarPath = `/schemas/system/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all system schemas by username. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all system schemas by username.
     * @param {string} username Username.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemUsernameGet: async (
      username: string,
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('schemasSystemUsernameGet', 'username', username);
      const localVarPath = `/schemas/system/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new system schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new system schema.
     * @param {string} username Username.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemUsernamePost: async (
      username: string,
      schema: Schema,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('schemasSystemUsernamePost', 'username', username);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasSystemUsernamePost', 'schema', schema);
      const localVarPath = `/schemas/system/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdGet: async (
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdGet', 'topicId', topicId);
      const localVarPath = `/schemas/{topicId}`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportFilePost: async (
      topicId: string,
      body: any,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdImportFilePost', 'topicId', topicId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasTopicIdImportFilePost', 'body', body);
      const localVarPath = `/schemas/{topicId}/import/file`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportMessagePost: async (
      topicId: string,
      inlineObject2: InlineObject2,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdImportMessagePost', 'topicId', topicId);
      // verify required parameter 'inlineObject2' is not null or undefined
      assertParamExists(
        'schemasTopicIdImportMessagePost',
        'inlineObject2',
        inlineObject2,
      );
      const localVarPath = `/schemas/{topicId}/import/message`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdPost: async (
      topicId: string,
      schema: Schema,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdPost', 'topicId', topicId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasTopicIdPost', 'schema', schema);
      const localVarPath = `/schemas/{topicId}`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Finds the schema using the json document type.
     * @summary Returns schema by type.
     * @param {string} type JSON type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTypeTypeGet: async (
      type: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('schemasTypeTypeGet', 'type', type);
      const localVarPath = `/schemas/type/{type}`.replace(
        `{${'type'}}`,
        encodeURIComponent(String(type)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schemasGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the schema from a zip file. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasImportFilePreviewPost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportFilePreviewPost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasImportMessagePreviewPost(
      inlineObject4: InlineObject4,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportMessagePreviewPost(
          inlineObject4,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasPushImportMessagePreviewPost(
      inlineObject5: InlineObject5,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasPushImportMessagePreviewPost(
          inlineObject5,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasPushSchemaIdPublishPut(
      schemaId: string,
      inlineObject1: InlineObject1,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasPushSchemaIdPublishPut(
          schemaId,
          inlineObject1,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasPushTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasPushTopicIdImportFilePost(
          topicId,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasPushTopicIdImportMessagePost(
      topicId: string,
      inlineObject3: InlineObject3,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasPushTopicIdImportMessagePost(
          topicId,
          inlineObject3,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasPushTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasPushTopicIdPost(
          topicId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdDelete(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdDelete(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns schema files for the schemas. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdExportFilePost(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdExportFilePost(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Standard Registry role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdExportMessagePost(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportSchema>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdExportMessagePost(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdPublishPut(
      schemaId: string,
      inlineObject: InlineObject,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdPublishPut(
          schemaId,
          inlineObject,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdPut(
          schemaId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Finds the schema using the schema type.
     * @summary Returns schema by schema type.
     * @param {'STANDARD_REGISTRY' | 'USER' | 'POLICY' | 'MINT_TOKEN' | 'WIPE_TOKEN' | 'MINT_NFTOKEN'} schemaEntity schema type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemEntitySchemaEntityGet(
      schemaEntity:
        | 'STANDARD_REGISTRY'
        | 'USER'
        | 'POLICY'
        | 'MINT_TOKEN'
        | 'WIPE_TOKEN'
        | 'MINT_NFTOKEN',
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemEntitySchemaEntityGet(
          schemaEntity,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Makes the selected scheme active. Other schemes of the same type become inactive. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemSchemaIdActivePut(
      schemaId: string,
      inlineObject6: InlineObject6,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemSchemaIdActivePut(
          schemaId,
          inlineObject6,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemSchemaIdDelete(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemSchemaIdDelete(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemSchemaIdPut(
          schemaId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all system schemas by username. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all system schemas by username.
     * @param {string} username Username.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemUsernameGet(
      username: string,
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemUsernameGet(
          username,
          pageIndex,
          pageSize,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new system schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new system schema.
     * @param {string} username Username.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSystemUsernamePost(
      username: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSystemUsernamePost(
          username,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdGet(
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdGet(
          topicId,
          pageIndex,
          pageSize,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdImportFilePost(
          topicId,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdImportMessagePost(
      topicId: string,
      inlineObject2: InlineObject2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdImportMessagePost(
          topicId,
          inlineObject2,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdPost(
          topicId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Finds the schema using the json document type.
     * @summary Returns schema by type.
     * @param {string} type JSON type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTypeTypeGet(
      type: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTypeTypeGet(type, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SchemasApiFp(configuration);
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the schema from a zip file. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportFilePreviewPost(
      body: any,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportFilePreviewPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportMessagePreviewPost(
      inlineObject4: InlineObject4,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportMessagePreviewPost(inlineObject4, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushImportMessagePreviewPost(
      inlineObject5: InlineObject5,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .schemasPushImportMessagePreviewPost(inlineObject5, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushSchemaIdPublishPut(
      schemaId: string,
      inlineObject1: InlineObject1,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .schemasPushSchemaIdPublishPut(schemaId, inlineObject1, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .schemasPushTopicIdImportFilePost(topicId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdImportMessagePost(
      topicId: string,
      inlineObject3: InlineObject3,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .schemasPushTopicIdImportMessagePost(topicId, inlineObject3, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasPushTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .schemasPushTopicIdPost(topicId, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdDelete(
      schemaId: string,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdDelete(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns schema files for the schemas. Only users with the Standard Registry role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportFilePost(
      schemaId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .schemasSchemaIdExportFilePost(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Standard Registry role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportMessagePost(
      schemaId: string,
      options?: any,
    ): AxiosPromise<ExportSchema> {
      return localVarFp
        .schemasSchemaIdExportMessagePost(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPublishPut(
      schemaId: string,
      inlineObject: InlineObject,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdPut(schemaId, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Finds the schema using the schema type.
     * @summary Returns schema by schema type.
     * @param {'STANDARD_REGISTRY' | 'USER' | 'POLICY' | 'MINT_TOKEN' | 'WIPE_TOKEN' | 'MINT_NFTOKEN'} schemaEntity schema type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemEntitySchemaEntityGet(
      schemaEntity:
        | 'STANDARD_REGISTRY'
        | 'USER'
        | 'POLICY'
        | 'MINT_TOKEN'
        | 'WIPE_TOKEN'
        | 'MINT_NFTOKEN',
      options?: any,
    ): AxiosPromise<Schema> {
      return localVarFp
        .schemasSystemEntitySchemaEntityGet(schemaEntity, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Makes the selected scheme active. Other schemes of the same type become inactive. Only users with the Standard Registry role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdActivePut(
      schemaId: string,
      inlineObject6: InlineObject6,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSystemSchemaIdActivePut(schemaId, inlineObject6, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdDelete(
      schemaId: string,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSystemSchemaIdDelete(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSystemSchemaIdPut(schemaId, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all system schemas by username. Only users with the Standard Registry role are allowed to make the request.
     * @summary Returns all system schemas by username.
     * @param {string} username Username.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemUsernameGet(
      username: string,
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSystemUsernameGet(username, pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new system schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates new system schema.
     * @param {string} username Username.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSystemUsernamePost(
      username: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .schemasSystemUsernamePost(username, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdGet(
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdImportFilePost(topicId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportMessagePost(
      topicId: string,
      inlineObject2: InlineObject2,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .schemasTopicIdPost(topicId, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Finds the schema using the json document type.
     * @summary Returns schema by type.
     * @param {string} type JSON type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTypeTypeGet(type: string, options?: any): AxiosPromise<Schema> {
      return localVarFp
        .schemasTypeTypeGet(type, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI {
  /**
   * Returns all schemas.
   * @summary Returns all schemas.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the schema from a zip file. Only users with the Standard Registry role are allowed to make the request.
   * @summary Schema preview from a zip file.
   * @param {any} body A zip file containing the schema to be viewed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportFilePreviewPost(body: any, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasImportFilePreviewPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Schema preview from IPFS.
   * @param {InlineObject4} inlineObject4
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportMessagePreviewPost(
    inlineObject4: InlineObject4,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasImportMessagePreviewPost(inlineObject4, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the schema from IPFS without loading it into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Schema preview from IPFS.
   * @param {InlineObject5} inlineObject5
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPushImportMessagePreviewPost(
    inlineObject5: InlineObject5,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasPushImportMessagePreviewPost(inlineObject5, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic.
   * @param {string} schemaId Schema ID.
   * @param {InlineObject1} inlineObject1
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPushSchemaIdPublishPut(
    schemaId: string,
    inlineObject1: InlineObject1,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasPushSchemaIdPublishPut(schemaId, inlineObject1, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new schema from a zip file.
   * @param {string} topicId Topic ID.
   * @param {any} body A zip file containing schema to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPushTopicIdImportFilePost(
    topicId: string,
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasPushTopicIdImportFilePost(topicId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new schema from IPFS.
   * @param {string} topicId Topic ID.
   * @param {InlineObject3} inlineObject3
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPushTopicIdImportMessagePost(
    topicId: string,
    inlineObject3: InlineObject3,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasPushTopicIdImportMessagePost(topicId, inlineObject3, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
   * @summary Create new schema.
   * @param {string} topicId Topic ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPushTopicIdPost(
    topicId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasPushTopicIdPost(topicId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Deletes the schema.
   * @param {string} schemaId Schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdDelete(schemaId: string, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdDelete(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns schema files for the schemas. Only users with the Standard Registry role are allowed to make the request.
   * @summary Return zip file with schemas.
   * @param {string} schemaId Selected schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdExportFilePost(
    schemaId: string,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdExportFilePost(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Standard Registry role are allowed to make the request.
   * @summary List Hedera message IDs of published schemas.
   * @param {string} schemaId Selected schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdExportMessagePost(
    schemaId: string,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdExportMessagePost(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the schema.
   * @param {string} schemaId Schema ID.
   * @param {InlineObject} inlineObject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdPublishPut(
    schemaId: string,
    inlineObject: InlineObject,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Updates the schema.
   * @param {string} schemaId Schema ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdPut(
    schemaId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdPut(schemaId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Finds the schema using the schema type.
   * @summary Returns schema by schema type.
   * @param {'STANDARD_REGISTRY' | 'USER' | 'POLICY' | 'MINT_TOKEN' | 'WIPE_TOKEN' | 'MINT_NFTOKEN'} schemaEntity schema type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemEntitySchemaEntityGet(
    schemaEntity:
      | 'STANDARD_REGISTRY'
      | 'USER'
      | 'POLICY'
      | 'MINT_TOKEN'
      | 'WIPE_TOKEN'
      | 'MINT_NFTOKEN',
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemEntitySchemaEntityGet(schemaEntity, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Makes the selected scheme active. Other schemes of the same type become inactive. Only users with the Standard Registry role are allowed to make the request.
   * @summary Publishes the schema.
   * @param {string} schemaId Schema ID.
   * @param {InlineObject6} inlineObject6
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemSchemaIdActivePut(
    schemaId: string,
    inlineObject6: InlineObject6,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemSchemaIdActivePut(schemaId, inlineObject6, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Deletes the schema.
   * @param {string} schemaId Schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemSchemaIdDelete(
    schemaId: string,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemSchemaIdDelete(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the system schema with the provided schema ID. Only users with the Standard Registry role are allowed to make the request.
   * @summary Updates the schema.
   * @param {string} schemaId Schema ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemSchemaIdPut(
    schemaId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemSchemaIdPut(schemaId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all system schemas by username. Only users with the Standard Registry role are allowed to make the request.
   * @summary Returns all system schemas by username.
   * @param {string} username Username.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set.
   * @param {number} [pageSize] The number of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemUsernameGet(
    username: string,
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemUsernameGet(username, pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new system schema. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates new system schema.
   * @param {string} username Username.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSystemUsernamePost(
    username: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSystemUsernamePost(username, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all schemas by topicId.
   * @summary Returns all schemas by topicId.
   * @param {string} topicId Topic ID.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdGet(
    topicId: string,
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from a zip file into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new schema from a zip file.
   * @param {string} topicId Topic ID.
   * @param {any} body A zip file containing schema to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdImportFilePost(
    topicId: string,
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdImportFilePost(topicId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from IPFS into the local DB. Only users with the Standard Registry role are allowed to make the request.
   * @summary Imports new schema from IPFS.
   * @param {string} topicId Topic ID.
   * @param {InlineObject2} inlineObject2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdImportMessagePost(
    topicId: string,
    inlineObject2: InlineObject2,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new schema. Only users with the Standard Registry role are allowed to make the request.
   * @summary Create new schema.
   * @param {string} topicId Topic ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdPost(
    topicId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdPost(topicId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Finds the schema using the json document type.
   * @summary Returns schema by type.
   * @param {string} type JSON type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTypeTypeGet(type: string, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasTypeTypeGet(type, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns current environment name.
     * @summary Returns current environment name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsEnvironmentGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings/environment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns current settings. For users with the Standard Registry role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set settings. For users with the Standard Registry role only.
     * @summary Set settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsPost: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns current environment name.
     * @summary Returns current environment name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsEnvironmentGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.settingsEnvironmentGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns current settings. For users with the Standard Registry role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSettings>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set settings. For users with the Standard Registry role only.
     * @summary Set settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPost(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SettingsApiFp(configuration);
  return {
    /**
     * Returns current environment name.
     * @summary Returns current environment name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsEnvironmentGet(options?: any): AxiosPromise<string> {
      return localVarFp
        .settingsEnvironmentGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns current settings. For users with the Standard Registry role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsGet(options?: any): AxiosPromise<CommonSettings> {
      return localVarFp
        .settingsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set settings. For users with the Standard Registry role only.
     * @summary Set settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .settingsPost(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   * Returns current environment name.
   * @summary Returns current environment name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsEnvironmentGet(options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsEnvironmentGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns current settings. For users with the Standard Registry role only.
   * @summary Returns current settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsGet(options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set settings. For users with the Standard Registry role only.
   * @summary Set settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsPost(options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsPost(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns task statuses by Id.
     * @summary Returns task statuses.
     * @param {string} taskId Task ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdGet: async (
      taskId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('tasksTaskIdGet', 'taskId', taskId);
      const localVarPath = `/tasks/{taskId}`.replace(
        `{${'taskId'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns task statuses by Id.
     * @summary Returns task statuses.
     * @param {string} taskId Task ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tasksTaskIdGet(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tasksTaskIdGet(
        taskId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     * Returns task statuses by Id.
     * @summary Returns task statuses.
     * @param {string} taskId Task ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksTaskIdGet(taskId: string, options?: any): AxiosPromise<TaskStatus> {
      return localVarFp
        .tasksTaskIdGet(taskId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   * Returns task statuses by Id.
   * @summary Returns task statuses.
   * @param {string} taskId Task ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public tasksTaskIdGet(taskId: string, options?: AxiosRequestConfig) {
    return TasksApiFp(this.configuration)
      .tasksTaskIdGet(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all tokens. For the Standard Registry role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet: async (
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPost: async (
      token: Token,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('tokensPost', 'token', token);
      const localVarPath = `/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        token,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushPost: async (
      token: Token,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('tokensPushPost', 'token', token);
      const localVarPath = `/tokens/push`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        token,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdAssociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensPushTokenIdAssociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/push/{tokenId}/associate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Disassociates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdDissociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensPushTokenIdDissociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/push/{tokenId}/dissociate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameFreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameFreezePut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameFreezePut',
        'username',
        username,
      );
      const localVarPath = `/tokens/push/{tokenId}/{username}/freeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameGrantKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameGrantKycPut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameGrantKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/push/{tokenId}/{username}/grantKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameRevokeKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameRevokeKycPut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameRevokeKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/push/{tokenId}/{username}/revokeKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameUnfreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameUnfreezePut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensPushTokenIdUsernameUnfreezePut',
        'username',
        username,
      );
      const localVarPath = `/tokens/push/{tokenId}/{username}/unfreeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdAssociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdAssociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/{tokenId}/associate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdDissociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdDissociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/{tokenId}/dissociate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameFreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameFreezePut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists('tokensTokenIdUsernameFreezePut', 'username', username);
      const localVarPath = `/tokens/{tokenId}/{username}/freeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameGrantKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameGrantKycPut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameGrantKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/grantKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user information for the selected token. Only users with the Standard Registry role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameInfoGet: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameInfoGet', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists('tokensTokenIdUsernameInfoGet', 'username', username);
      const localVarPath = `/tokens/{tokenId}/{username}/info`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameRevokeKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameRevokeKycPut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameRevokeKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/revokeKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameUnfreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameUnfreezePut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameUnfreezePut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/unfreeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all tokens. For the Standard Registry role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenInfo & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPost(
      token: Token,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenInfo & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokensPost(
        token,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushPost(
      token: Token,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokensPushPost(
        token,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdAssociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdAssociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Disassociates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdDissociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdDissociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdUsernameFreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdUsernameGrantKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdUsernameRevokeKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPushTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensPushTokenIdUsernameUnfreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdAssociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdAssociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdDissociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdDissociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameFreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameGrantKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user information for the selected token. Only users with the Standard Registry role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameInfoGet(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameInfoGet(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameRevokeKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameUnfreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TokensApiFp(configuration);
  return {
    /**
     * Returns all tokens. For the Standard Registry role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): AxiosPromise<Array<TokenInfo & object>> {
      return localVarFp
        .tokensGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPost(
      token: Token,
      options?: any,
    ): AxiosPromise<Array<TokenInfo & object>> {
      return localVarFp
        .tokensPost(token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushPost(token: Token, options?: any): AxiosPromise<Task> {
      return localVarFp
        .tokensPushPost(token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdAssociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdAssociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
     * @summary Disassociates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdDissociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdDissociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdUsernameFreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdUsernameGrantKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdUsernameRevokeKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPushTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<Task> {
      return localVarFp
        .tokensPushTokenIdUsernameUnfreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdAssociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .tokensTokenIdAssociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdDissociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .tokensTokenIdDissociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameFreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user information for the selected token. Only users with the Standard Registry role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameInfoGet(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameInfoGet(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
  /**
   * Returns all tokens. For the Standard Registry role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
   * @summary Return a list of tokens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensGet(options?: AxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .tokensGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates a new token.
   * @param {Token} token Object that contains token information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPost(token: Token, options?: AxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .tokensPost(token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new token. Only users with the Standard Registry role are allowed to make the request.
   * @summary Creates a new token.
   * @param {Token} token Object that contains token information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushPost(token: Token, options?: AxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .tokensPushPost(token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
   * @summary Associates the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdAssociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdAssociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Disassociates the user with the provided Hedera token. Only users with the Standard Registry role are allowed to make the request.
   * @summary Disassociates the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdDissociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdDissociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Freeze transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdUsernameFreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdUsernameFreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Sets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdUsernameGrantKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdUsernameGrantKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Unsets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdUsernameRevokeKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdUsernameRevokeKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Unfreezes transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPushTokenIdUsernameUnfreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensPushTokenIdUsernameUnfreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
   * @summary Associates the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdAssociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdAssociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
   * @summary Associate the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdDissociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdDissociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Freezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Freeze transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameFreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameFreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Sets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameGrantKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user information for the selected token. Only users with the Standard Registry role are allowed to make the request.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameInfoGet(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameInfoGet(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unsets the KYC flag for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Unsets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameRevokeKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unfreezes transfers of the specified token for the user. Only users with the Standard Registry role are allowed to make the request.
   * @summary Unfreezes transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameUnfreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TrustchainsApi - axios parameter creator
 * @export
 */
export const TrustchainsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {string} [policyId] Selected policy ID.
     * @param {string} [policyOwner] Selected Standard Registry (DID).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsGet: async (
      pageIndex?: number,
      pageSize?: number,
      policyId?: string,
      policyOwner?: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      const localVarPath = `/trustchains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (policyId !== undefined) {
        localVarQueryParameter['policyId'] = policyId;
      }

      if (policyOwner !== undefined) {
        localVarQueryParameter['policyOwner'] = policyOwner;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsHashGet: async (
      hash: string,
      options: AxiosRequestConfig = {} as any,
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('trustchainsHashGet', 'hash', hash);
      const localVarPath = `/trustchains/{hash}`.replace(
        `{${'hash'}}`,
        encodeURIComponent(String(hash)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TrustchainsApi - functional programming interface
 * @export
 */
export const TrustchainsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TrustchainsApiAxiosParamCreator(configuration);
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {string} [policyId] Selected policy ID.
     * @param {string} [policyOwner] Selected Standard Registry (DID).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trustchainsGet(
      pageIndex?: number,
      pageSize?: number,
      policyId?: string,
      policyOwner?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<VerifiablePresentation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trustchainsGet(
        pageIndex,
        pageSize,
        policyId,
        policyOwner,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trustchainsHashGet(
      hash: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustChains>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.trustchainsHashGet(hash, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TrustchainsApi - factory interface
 * @export
 */
export const TrustchainsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TrustchainsApiFp(configuration);
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {string} [policyId] Selected policy ID.
     * @param {string} [policyOwner] Selected Standard Registry (DID).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsGet(
      pageIndex?: number,
      pageSize?: number,
      policyId?: string,
      policyOwner?: string,
      options?: any,
    ): AxiosPromise<Array<VerifiablePresentation>> {
      return localVarFp
        .trustchainsGet(pageIndex, pageSize, policyId, policyOwner, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsHashGet(hash: string, options?: any): AxiosPromise<TrustChains> {
      return localVarFp
        .trustchainsHashGet(hash, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TrustchainsApi - object-oriented interface
 * @export
 * @class TrustchainsApi
 * @extends {BaseAPI}
 */
export class TrustchainsApi extends BaseAPI {
  /**
   * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
   * @summary Returns a list of all VP documents.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {string} [policyId] Selected policy ID.
   * @param {string} [policyOwner] Selected Standard Registry (DID).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TrustchainsApi
   */
  public trustchainsGet(
    pageIndex?: number,
    pageSize?: number,
    policyId?: string,
    policyOwner?: string,
    options?: AxiosRequestConfig,
  ) {
    return TrustchainsApiFp(this.configuration)
      .trustchainsGet(pageIndex, pageSize, policyId, policyOwner, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
   * @summary Returns a trustchain for a VP document.
   * @param {string} hash Hash or ID of a VP document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TrustchainsApi
   */
  public trustchainsHashGet(hash: string, options?: AxiosRequestConfig) {
    return TrustchainsApiFp(this.configuration)
      .trustchainsHashGet(hash, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
